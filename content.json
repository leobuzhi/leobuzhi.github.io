{"meta":{"title":"Joey'blog","subtitle":"留住温度、速度、温柔和愤怒。","description":null,"author":"Joey Chen","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"skiplist的golang实现","slug":"skiplist的golang实现","date":"2017-12-22T12:33:06.000Z","updated":"2017-12-27T13:52:12.823Z","comments":true,"path":"2017/12/22/skiplist的golang实现/","link":"","permalink":"http://yoursite.com/2017/12/22/skiplist的golang实现/","excerpt":"半年前把redis源码看了大部分，这段时间一直在学习Golang的各种东西，想起了以前在redis里面看到的sorted-set数据结构，想着用Golang实现一个。","text":"半年前把redis源码看了大部分，这段时间一直在学习Golang的各种东西，想起了以前在redis里面看到的sorted-set数据结构，想着用Golang实现一个。 什么是skipList&emsp;&emsp;在计算机科学领域，跳跃链表是一种数据结构，允许快速查询一个有序连续元素的数据链表。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(log n)平均时间）。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表，因此得名。所有操作都以对数随机化的时间进行。 &emsp;&emsp;要查找一个目标元素，起步于头元素和顶层列表，并沿着每个链表搜索，直到到达小于或着等于目标的最后一个元素。通过跟踪起自目标直到到达在更高列表中出现的元素的反向查找路径，在每个链表中预期的步数显而易见是 1/p。所以查找的总体代价是 O((log1/p n) / p)，当p 是常数时是 O(log n)。通过选择不同 p 值，就可以在查找代价和存储代价之间作出权衡。插入和删除的实现非常像相应的链表操作，除了”高层”元素必须在多个链表中插入或删除之外。跳跃列表不像某些传统平衡树数据结构那样提供绝对的最坏情况性能保证，因为用来建造跳跃列表的扔硬币方法总有可能（尽管概率很小）生成一个糟糕的不平衡结构。但是在实际中它工作的很好，随机化平衡方案比在平衡二叉查找树中用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用，这里的插入可以在跳跃列表不同的部分并行的进行，而不用全局的数据结构重新平衡。[1] 实现1234567891011121314151617181920212223242526272829//每个节点储存k,v，向前跳跃的节点指针，向后一步的节点指针type node struct &#123; forward []*node backward *node key, value interface&#123;&#125;&#125;//每个跳跃表因为要求有序，所以需要一个比较函数，header指针为了更好的查找，不是必要的。type SkipList struct &#123; lessThan func(l, r interface&#123;&#125;) bool header *node footer *node length int MaxLevel int&#125;//SkipList会实现这个接口以实现迭代type Iterator interface &#123; //如果可向后迭代则指向下一个节点，并返回true，否则返回false Next() (ok bool) //如果可向前迭代则指向上一个节点，并返回true，否则返回false Previous() (ok bool) //返回当前节点的key Key() interface&#123;&#125; //返回当前节点的value Value() interface&#123;&#125; //迭代器移至某个key的位置 Seek(key interface&#123;&#125;) (ok bool) //关闭迭代器并回收资源，不是必要的，但对GC有好处 Close()&#125; 查找123456789101112131415161718192021222324func (s *SkipList) Get(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123; candidate := s.getPath(s.header, nil, key) if candidate == nil || candidate.key != key &#123; return nil, false &#125; return candidate.value, true&#125;//从头结点开始查找候选节点，如果候选节点存在并且它的key等于需要查找的key，则找到返回。//getPath方法，是实现SkipList关键之一func (s *SkipList) getPath(current *node, update []*node, key interface&#123;&#125;) *node &#123; depth := len(current.forward) - 1 for i := depth; i &gt;= 0; i-- &#123; for current.forward[i] != nil &amp;&amp; s.lessThan(current.forward[i].key, key) &#123; current = current.forward[i] &#125; if update != nil &#123; update[i] = current &#125; &#125; return current.next()&#125;//从SkipList的最高层级开始遍历，如果后续节点不为空，并且后续节点的key小于要查找的key，那么SkipList向后跳跃一个节点;如果只是查找，update为nil，更新则需要修改相关节点的指针 插入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func (s *SkipList) Set(key, value interface&#123;&#125;) &#123; if key == nil &#123; panic(&quot;nil key is not supported&quot;) &#125; update := make([]*node, s.level()+1, s.effectiveMaxLevel()+1) candidate := s.getPath(s.header, update, key) if candidate != nil &amp;&amp; candidate.key == key &#123; candidate.value = value return &#125; newLevel := s.randomLevel() if currentLevel := s.level(); newLevel &gt; currentLevel &#123; for i := currentLevel + 1; i &lt;= newLevel; i++ &#123; update = append(update, s.header) s.header.forward = append(s.header.forward, nil) &#125; &#125; newNode := &amp;node&#123; forward: make([]*node, newLevel+1, s.effectiveMaxLevel()+1), key: key, value: value, &#125; if previous := update[0]; previous.key != nil &#123; newNode.backward = previous &#125; for i := 0; i &lt;= newLevel; i++ &#123; newNode.forward[i] = update[i].forward[i] update[i].forward[i] = newNode &#125; s.length++ if newNode.forward[0] != nil &#123; if newNode.forward[0].backward != newNode &#123; newNode.forward[0].backward = newNode &#125; &#125; if s.footer == nil || s.lessThan(s.footer.key, key) &#123; s.footer = newNode &#125;&#125;//先去查找skiplist中是否有插入节点的key值，如果有，就直接更新该key的value，没有的话，已经找到了需要插入的位置，更新对应的节点即可[2] 每插入一个节点，都给予随机层级123456func (s SkipList) randomLevel() (n int) &#123; for n = 0; n &lt; s.effectiveMaxLevel() &amp;&amp; rand.Float64() &lt; p; n++ &#123; &#125; return n&#125;//关于P的选取，大多数实现为0.25或0.5，原因可以参考skiplist的论文[3] 删除123456789101112131415161718192021222324252627282930313233func (s *SkipList) Delete(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123; if key == nil &#123; panic(&quot;nil key is not supported&quot;) &#125; update := make([]*node, s.level()+1, s.effectiveMaxLevel()) candidate := s.getPath(s.header, update, key) if candidate == nil || candidate.key != key &#123; return nil, false &#125; previous := candidate.backward if s.footer == candidate &#123; s.footer = previous &#125; next := candidate.next() if next != nil &#123; next.backward = previous &#125; for i := 0; i &lt;= s.level() &amp;&amp; update[i].forward[i] == candidate; i++ &#123; update[i].forward[i] = candidate.forward[i] &#125; for s.level() &gt; 0 &amp;&amp; s.header.forward[s.level()] == nil &#123; s.header.forward = s.header.forward[:s.level()] &#125; s.length-- return candidate.value, true&#125;//找到对应key值节点所在的位置，并删除相关节点，返回节点的value和true 完整的实现：https://github.com/leobuzhi/skipList-go [1] https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8[2] chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=http%3A%2F%2Fwww.cl.cam.ac.uk%2Fteaching%2F0506%2FAlgorithms%2Fskiplists.pdf[3] chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fcs.uwaterloo.ca%2Fresearch%2Ftr%2F1993%2F28%2Froot2side.pdf","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"golang123源码分析","slug":"golang123源码分析","date":"2017-12-08T13:07:16.000Z","updated":"2017-12-08T13:10:09.000Z","comments":true,"path":"2017/12/08/golang123源码分析/","link":"","permalink":"http://yoursite.com/2017/12/08/golang123源码分析/","excerpt":"golang123 源码分析最近研究了一个名为golang123的开源的Web项目，想写一篇关于这个项目的源码分析。","text":"golang123 源码分析最近研究了一个名为golang123的开源的Web项目，想写一篇关于这个项目的源码分析。 一、目录结构 gopath/src/github.com/shen100/golang123 config controller manager model nginx route sql utils website config.example.json main.go config 用于实例化服务器配置文件、redis、mysql controller 路由调用API manager 用于管理redis连接和session ，主要是用了 12&quot;github.com/garyburd/redigo/redis&quot;&quot;github.com/kataras/iris/sessions&quot; model 一些和数据库打交道的操作 nginx nginx的配置文件和httpds的密钥 route 外部访问的路由 sql mysql的数据库表结构 utils 时间操作的工具、简书爬虫、反射工具（用于解析自定义json配置文件）、Markdown转HTML的工具、主要是用了 12&quot;github.com/russross/blackfriday&quot;&quot;github.com/microcosm-cc/bluemonday&quot; website web的根目录，技术栈为 vue、nuxt、node.js config.example.json 项目的配置文件 main.go 后端RESTful API 入口 二、controller结构 article 提供对文章操作的API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172func queryList(isBackend bool, ctx iris.Context) &#123; ...&#125;// List 文章列表func List(ctx iris.Context) &#123; queryList(false, ctx)&#125;// AllList 文章列表，后台管理提供的接口func AllList(ctx iris.Context) &#123; queryList(true, ctx)&#125;// UserArticleList 查询用户的文章func UserArticleList(ctx iris.Context) &#123; ...&#125;// ListMaxComment 评论最多的文章，返回5条func ListMaxComment(ctx iris.Context) &#123; ...&#125;// ListMaxBrowse 访问量最多的文章，返回5条func ListMaxBrowse(ctx iris.Context) &#123; ...&#125;func save(isEdit bool, ctx iris.Context) &#123; ...&#125;// Create 创建文章func Create(ctx iris.Context) &#123; save(false, ctx); &#125;// Update 更新文章func Update(ctx iris.Context) &#123; save(true, ctx); &#125;// Info 获取文章信息func Info(ctx iris.Context) &#123; ...&#125;// UpdateStatus 更新文章状态func UpdateStatus(ctx iris.Context) &#123; ...&#125;// Top 文章置顶func Top(ctx iris.Context) &#123; ...&#125;// DeleteTop 取消文章置顶func DeleteTop(ctx iris.Context) &#123; ...&#125;// Tops 所有置顶文章func Tops(ctx iris.Context) &#123; ...&#125;// Delete 删除文章func Delete(ctx iris.Context) &#123; ...&#125; auth 提供一些验证的API 12345678910111213141516171819// SigninRequired 必须是登录用户func SigninRequired(ctx iris.Context) &#123; ...&#125;// ActiveRequired 用户必须是激活状态func ActiveRequired(ctx iris.Context) &#123; ...&#125;// EditorRequired 必须是网站编辑func EditorRequired(ctx iris.Context) &#123; ...&#125;// AdminRequired 必须是管理员func AdminRequired(ctx iris.Context) &#123; ...&#125; category 提供关于分类的API 123456789101112131415161718192021222324// Save 保存分类（创建或更新）func Save(isEdit bool, ctx iris.Context) &#123; ...&#125;// Create 创建分类func Create(ctx iris.Context) &#123; Save(false, ctx)&#125;// Update 更新分类func Update(ctx iris.Context) &#123; Save(true, ctx) &#125;// Info 获取分类信息func Info(ctx iris.Context) &#123; ...&#125;// List 分类列表func List(ctx iris.Context) &#123; ...&#125; collect 提供关于收藏的API 123456789101112131415161718192021222324252627282930313233// CreateCollect 收藏文章或收藏投票func CreateCollect(ctx iris.Context) &#123; ...&#125;// DeleteCollect 删除收藏func DeleteCollect(ctx iris.Context) &#123; ...&#125;// Collects 根据收藏夹查询用户已收藏的话题或投票func Collects(ctx iris.Context) &#123; ...&#125;// CreateFolder 创建收藏夹func CreateFolder(ctx iris.Context) &#123; ...&#125;func queryFolders(userID int) ([]model.Folder, error) &#123; ...&#125;// Folders 查询用户的收藏夹列表func Folders(ctx iris.Context) &#123; ...&#125;// FoldersWithSource 查询用户的收藏夹列表，并且返回每个收藏夹中收藏了哪些话题或投票func FoldersWithSource(ctx iris.Context) &#123; ...&#125; comment 提供关于评论的API 1234567891011121314151617181920212223242526272829// Save 保存评论（创建或更新）func Save(isEdit bool, ctx iris.Context) &#123; ...&#125;// Create 创建评论func Create(ctx iris.Context) &#123; Save(false, ctx)&#125;// Update 更新评论func Update(ctx iris.Context) &#123; Save(true, ctx) &#125;// Delete 删除评论func Delete(ctx iris.Context) &#123; ...&#125;// UserCommentList 查询用户的评论func UserCommentList(ctx iris.Context) &#123; ...&#125;// SourceComments 查询话题或投票的评论func SourceComments(ctx iris.Context) &#123; ...&#125; common 提供一些公共的API 123456789101112131415// SendErrJSON 有错误发生时，发送错误JSONfunc SendErrJSON(msg string, args ...interface&#123;&#125;) &#123; ...&#125;// SessShiftExpiration 延时session过期func SessShiftExpiration(ctx iris.Context) &#123; manager.Sess.ShiftExpiration(ctx) ctx.Next()&#125;// Upload 文件上传func Upload(ctx iris.Context) &#123; ...&#125; crawler 提供爬虫爬取文章API 12345678910111213func isImgURLValid(imgURL string) bool &#123; ...&#125;// jianShuCrawl 简书爬虫func jianShuCrawl(pageURL string, ch chan map[string]string) &#123; ...&#125;// Crawl 抓取文章func Crawl(ctx iris.Context) &#123; ...&#125; mail 提供发送邮件API 12345678910111213141516// SendMail 发送邮件func SendMail(toEmail, subject, content string) error &#123; ...&#125;//参考net/smtp的func SendMail()//使用net.Dial连接tls(ssl)端口时, smtp.NewClient()会卡住且不提示err//len(to) &gt; 1 时, to[1]开始提示是密送func sendMailUsingTLS(addr string, auth smtp.Auth, from string, to []string, message string) error &#123; ...&#125;func createSMTPClient(addr string) (*smtp.Client, error) &#123; ...&#125; message 提供关于消息的API 123456789// Unread 未读消息func Unread(ctx iris.Context) &#123; ...&#125;// UnreadCount 未读消息数量func UnreadCount(ctx iris.Context) &#123; ...&#125; user 提供关于用户的一些API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111func sendMail(action string, title string, curTime int64, user model.User, ctx iris.Context) &#123; ...&#125;func verifyLink(cacheKey string, ctx iris.Context) (model.User, error) &#123; ...&#125;// ActiveSendMail 发送激活账号的邮件func ActiveSendMail(ctx iris.Context) &#123; ...&#125;// ActiveAccount 激活账号func ActiveAccount(ctx iris.Context) &#123; ...&#125;// ResetPasswordMail 发送重置密码的邮件func ResetPasswordMail(ctx iris.Context) &#123; ...&#125;// VerifyResetPasswordLink 验证重置密码的链接是否失效func VerifyResetPasswordLink(ctx iris.Context) &#123; ...&#125;// ResetPassword 重置密码func ResetPassword(ctx iris.Context) &#123; ...&#125;// Signin 用户登录func Signin(ctx iris.Context) &#123; ...&#125;// Signup 用户注册func Signup(ctx iris.Context) &#123; ...&#125;// Signout 退出登录func Signout(ctx iris.Context) &#123; ...&#125;// UpdateInfo 更新用户信息func UpdateInfo(ctx iris.Context) &#123; ...&#125;// UpdatePassword 更新用户密码func UpdatePassword(ctx iris.Context) &#123; ...&#125;// PublicInfo 用户公开的信息func PublicInfo(ctx iris.Context) &#123; ...&#125;// SecretInfo 返回用户信息，包含一些私密字段func SecretInfo(ctx iris.Context) &#123; ...&#125;// InfoDetail 返回用户详情信息，包含一些私密字段func InfoDetail(ctx iris.Context) &#123; ...&#125;// AllList 查询用户列表，只有管理员才能调此接口func AllList(ctx iris.Context) &#123; ...&#125;func topN(n int, ctx iris.Context) &#123; ...&#125;// Top10 返回积分排名前10的用户func Top10(ctx iris.Context) &#123; topN(10, ctx)&#125;// Top100 返回积分排名前100的用户func Top100(ctx iris.Context) &#123; topN(100, ctx)&#125;// AddCareer 添加职业经历func AddCareer(ctx iris.Context) &#123; ...&#125;// AddSchool 添加教育经历func AddSchool(ctx iris.Context) &#123; ...&#125;// DeleteCareer 删除职业经历func DeleteCareer(ctx iris.Context) &#123; ...&#125;// DeleteSchool 删除教育经历func DeleteSchool(ctx iris.Context) &#123; ...&#125; vote 提供投票API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// List 查询投票列表func List(ctx iris.Context) &#123; ...&#125;// ListMaxComment 评论最多的话题，返回5条func ListMaxComment(ctx iris.Context) &#123; ...&#125;// ListMaxBrowse 访问量最多的投票，返回5条func ListMaxBrowse(ctx iris.Context) &#123; ...&#125;func save(isEdit bool, vote model.Vote, user model.User, tx *gorm.DB) (model.Vote, error) &#123; ...&#125;// Create 创建投票func Create(ctx iris.Context) &#123; ...&#125;// Update 更新投票func Update(ctx iris.Context) &#123; ...&#125;// Info 查询投票func Info(ctx iris.Context) &#123; ...&#125;// Delete 删除投票func Delete(ctx iris.Context) &#123; ...&#125;func saveVoteItem(voteItem model.VoteItem, tx *gorm.DB) (model.VoteItem, error) &#123; ...&#125;// CreateVoteItem 创建投票项func CreateVoteItem(ctx iris.Context) &#123; ...&#125;// UserVoteVoteItem 用户投了一票func UserVoteVoteItem(ctx iris.Context) &#123; ...&#125;// EditVoteItem 编辑投票项func EditVoteItem(ctx iris.Context) &#123; ...&#125;// DeleteItem 删除投票项func DeleteItem(ctx iris.Context) &#123; ...&#125;// UserVoteList 用户参与的投票func UserVoteList(ctx iris.Context) &#123; ...&#125; 三、nginx配置文件结构 监听了80和443端口分别是http和https 协议，访问http默认重定向到https access_log 和 error_log 分别为访问、错误日志文件路径 ssl_certificate 和 ssl_certificate_key 分别是证书和密钥的路径 / 用于nignx反向代理到Node.JS处理，Node.JS监听8020端口，处理前端的请求 /api 用于nignx反向代理到Golang处理，Golang监听8023端口，处理后端API 四、总结总体来说项目还是比较简单的，使用Golang来提供后端RESTful API，mysql做数据存储，redis做缓存层，然后用个nginx做项目的反向代理，项目结构清晰，是个值得学习的好项目。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"RESTful","slug":"RESTful","permalink":"http://yoursite.com/tags/RESTful/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"malloc之后再进行free，free的内存空间一定被OS回收了吗","slug":"malloc之后再进行free，free的内存空间一定被OS回收了吗","date":"2017-12-08T11:37:37.000Z","updated":"2017-12-08T11:40:18.000Z","comments":true,"path":"2017/12/08/malloc之后再进行free，free的内存空间一定被OS回收了吗/","link":"","permalink":"http://yoursite.com/2017/12/08/malloc之后再进行free，free的内存空间一定被OS回收了吗/","excerpt":"1.malloc之后如果不free，那么进程正常(或异常)结束后，操作系统是否一定会对这块内存进行回收呢？2.malloc之后如果调用了free，那么有没有什么情况下，操作系统不对这块内存进行回收呢？或者说暂时不进行回收呢？","text":"1.malloc之后如果不free，那么进程正常(或异常)结束后，操作系统是否一定会对这块内存进行回收呢？2.malloc之后如果调用了free，那么有没有什么情况下，操作系统不对这块内存进行回收呢？或者说暂时不进行回收呢？ 1 、会的，内存也是资源，操作系统会回收的。若不回收，你每次都异常退出去，多来几次，那岂不是你的内存直接就没了 2、 若是glibc，你所free掉的内存，不一定会马上被OS回收，这是合理的。试想一下，你每次free掉的内存都还给OS的话，尤其是在小字节的情况下，那么造成的情况，就是一大块的内存被你弄的千疮百孔，也就是说一块内存，里面有很多gap。而在操作系统的虚拟内存管理中，更是管理着的是固定大小的内存，如4K，那你还给我1 Byte，OS显然是很尴尬的。于是为了避免这样的问题，那么内存管理一般会有一个free block list，free掉的东西就放在这里来。那么你可能会释放很散乱的内存过来，没关系，我们在这里会尝试合并这些散乱的block，而malloc首先找的也是free block list，而非从OS申请新的内存。那么此时如果找到了一块儿合适的自然最好，如果找到的是比要的更大，那么一部分malloc，另一部分放回去。而上面有同学提到了小内存的问题，而这也是free block list在头部会有一些所谓的administrative data，所以用标准的malloc和free管理小内存是不高效，因为越小越容易造成gap。当然，由于malloc和free是如此普遍，自然会尝试着让它变的更好，所以也有各种优化，如对free block list进行chunk size排序等。 在 The Linux Programming Interface 这本书的7.1.2节中也有提到Allocating Memory on the Heap: malloc() and free()In general, C programs use the malloc family of functions to allocate and deallocatememory on the heap. These functions offer several advantages over brk() andsbrk(). In particular, they:􀁺 are standardized as part of the C language;􀁺 are easier to use in threaded programs;􀁺 provide a simple interface that allows memory to be allocated in smallunits; and􀁺 allow us to arbitrarily deallocate blocks of memory, which are maintained on a &lt;——–这里free list and recycled in future calls to allocate memory.The malloc() function allocates size bytes from the heap and returns","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"关于帧同步与状态同步","slug":"关于帧同步与状态同步","date":"2017-09-24T14:12:14.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2017/09/24/关于帧同步与状态同步/","link":"","permalink":"http://yoursite.com/2017/09/24/关于帧同步与状态同步/","excerpt":"游戏的战斗模块一直是游戏开发的重要部分，对于游戏的同步技术，有必要写一篇博客来深度学习一下。","text":"游戏的战斗模块一直是游戏开发的重要部分，对于游戏的同步技术，有必要写一篇博客来深度学习一下。 从操作方式上可以分为回合操作、即时操作。 从交互方式上可以分为离线战斗、联网战斗。 举例： 阴阳师：联网战斗、回合操作 神无月：离线战斗、联网战斗、回合操作 王者荣耀：联网战斗、即时操作 全民超神：联网战斗、即时操作 COC：离线战斗 海岛奇兵：离线战斗 对于联网游戏来说，同步方式分为两种，帧同步、状态同步（CS同步） 状态同步：将玩家的状态行为同步的方式，一般情况下，AI逻辑，技能逻辑，战斗计算都由服务器运算，算完了发给客户端展示。比如A玩家向B玩家发起攻击技能，服务器经过计算后，B玩家应该扣掉100血，服务器发给A,B玩家一些信息，A,B玩家分别更新自己本地的动作状态、buff状态、位置信息等等。一般来说状态同步的数据量会比较大，所以为了减轻服务器的计算压力，会把一部分计算放到客户端来做，但是服务器一定做校验。 帧同步：RTS游戏常常采用的同步技术，在单位数量很多的情况下，状态同步需要的计算量非常大，如果同步所有状态的话，对网络压力以及服务器计算都是非常大的挑战，帧同步只同步玩家的操作，每个玩家接受到别人的操作以后，通过本地的运算，可以达到一致的状态。这样随着单位的大量增加，同步量也不会变的非常大。比如皇室战争就是采用帧同步，A玩家可以把自己放置卡牌的位置坐标和卡牌ID发给服务器，服务器经过校验发过来的指令后可以转发给B玩家，B玩家在本地计算结果。这种方式可以很好的做到战斗回放。 战斗分类/同步技术 状态同步 帧同步 离线战斗、联网战斗 大部分计算逻辑在服务器，把结果发给客户端，一般需要服务器开发人员将服务器的逻辑写在客户端可以运行的模块 大部分逻辑在客户端，要求战斗逻辑部分与显示部分分离可以让逻辑部分代码客户端服务器公用，这部分代码可以来实现即时战斗和战斗校验 PVP、PVE战斗 可以实现 可以实现 网络流量 流量大 流量小 网络卡的表现 频繁出现玩家瞬移、掉血、回位等等 网络卡的时候整个战斗会停止，网络正常的时候会快速播放以让进度恢复正常 实现难度 需要客户端和服务器开发人员都比较有经验，需要不断的优化状态同步的方式，客户端需要做差值处理 客户端按照单机方式实现，保证显示层和逻辑层是分离的，保证显示层和逻辑层是分离的，保证逻辑层不要用到浮点数，不要用到不确定顺序的逻辑结构 总结： 状态同步：服务器实现整个游戏逻辑，安全性高，客户端压力减轻；客户端和服务器有频繁的数据同步，网络流量多，服务器实现整套游戏逻辑，承载压力大；开发效率比帧同步差。 帧同步：服务器只需要做转发逻辑，承载压力大；客户端与服务器仅需同步输入包，网络流少；所有逻辑都在客户端，减少了服务器开发与客户端开发的沟通，开发效率高。逻辑全在客户端，导致反外挂压力大；战斗核心逻辑，需要保证输入输出一致性，对开发人员要求高，调试难。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"同步技术","slug":"同步技术","permalink":"http://yoursite.com/tags/同步技术/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"mysql技术内幕-innodb存储引擎读书笔记第一章","slug":"mysql技术内幕-innodb存储引擎读书笔记第一章","date":"2017-09-23T15:00:20.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2017/09/23/mysql技术内幕-innodb存储引擎读书笔记第一章/","link":"","permalink":"http://yoursite.com/2017/09/23/mysql技术内幕-innodb存储引擎读书笔记第一章/","excerpt":"数据库：物理操作系统文件或其他形式文件类型的集合。在MySQL数据库中，数据库文件可以是frm，MYD，MYI，ibd结尾的文件。实例：MySQL数据库由后台线程以及一个共享内存区组成。MySQL数据库实例在系统上的表现就是一个进程。","text":"数据库：物理操作系统文件或其他形式文件类型的集合。在MySQL数据库中，数据库文件可以是frm，MYD，MYI，ibd结尾的文件。实例：MySQL数据库由后台线程以及一个共享内存区组成。MySQL数据库实例在系统上的表现就是一个进程。 MySQL配置文件：1# mysql --help | grep my.cnf 或者按名字找也可以12find / -name my.cnf/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf MySQL数据库是按多个配置文件顺序读取配置的，如果几个配置文件中都有同一个参数，MySQL数据库会以读取到的最后一个配置文件中的参数为准。 存储引擎是基于表的，而不是数据库。 InnoDB存储引擎：InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.58版本开始，InnoDB存储引擎是默认的存储引擎。对于表中数据的存储，InnoDB存储引擎采用了聚集（clustered）的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显示地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。 MyISAM存储引擎：MyISAM存储引擎不支持事务、表所设计，支持全文索引，主要面向一些OLAP数据库应用。MyISAM存储引擎的缓冲池只缓存（cache）索引文件，而不缓存数据文件，这点和大多数的数据库都非常不同。 连接MySQL1、TCP/IP2、命名管道和共享内存 //只有windows可用3、Unx域套接字123456mysql&gt; show variables like &apos;socket&apos;\\G;*************************** 1. row ***************************Variable_name: socket Value: /var/lib/mysql/mysql.sock1 row in set (0.00 sec)# mysql -S /var/lib/mysql/mysql.sock","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"innodb","slug":"innodb","permalink":"http://yoursite.com/tags/innodb/"}]},{"title":"golang使用grpc","slug":"golang使用grpc","date":"2017-09-19T14:06:08.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2017/09/19/golang使用grpc/","link":"","permalink":"http://yoursite.com/2017/09/19/golang使用grpc/","excerpt":"1.安装依赖的包文件，由于墙的原因，我们一些依赖的包文件可以通过下面方式下载到 从https://github.com/GoogleCloudPlatform/gcloud-golang 下载源文件，放置相应目录 1go install &quot;google.golang.org/cloud/compute/metadata&quot;","text":"1.安装依赖的包文件，由于墙的原因，我们一些依赖的包文件可以通过下面方式下载到 从https://github.com/GoogleCloudPlatform/gcloud-golang 下载源文件，放置相应目录 1go install &quot;google.golang.org/cloud/compute/metadata&quot; 从https://github.com/golang/oauth2 下载源文件，放置相应目录1go install &quot;golang.org/x/oauth2&quot; 从https://github.com/golang/net 下载源文件，放置相应目录1go install &quot;golang.org/x/net/context&quot; grpc使用protobuf来定义服务 Linux可以从https://github.com/golang/protobuf下载源文件，放置相应目录注意protobuf下面是没有go文件的，所以是12go install &quot;golang/protobuf/protoc-gen-go&quot;go install &quot;golang/protobuf/proto&quot; 而不是1go install &quot;golang/protobuf&quot; Windows可以直接在https://github.com/google/protobuf/releases/download/v3.4.0/protoc-3.4.0-win32.zip下载二进制文件，然后解压，把proto.exe 加入环境变量 3.测试grpc 从https://github.com/grpc/grpc-go 下载源文件，放置相应目录 1go install &quot;google.golang.org/grpc&quot; 新建目录树如下1234567891011121314151617root | |------server | | | |------testdata | | | | | |------route_guide_db.json | | | |------grpcServer.go | |------client | | | |------grpcClient.go | |------routeguide | |------route_guide.proto 文件内容如下 route_guide.proto123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// Copyright 2015 gRPC authors.//// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.syntax = &quot;proto3&quot;;option java_multiple_files = true;option java_package = &quot;io.grpc.examples.routeguide&quot;;option java_outer_classname = &quot;RouteGuideProto&quot;;package routeguide;// Interface exported by the server.service RouteGuide &#123; // A simple RPC. // // Obtains the feature at a given position. // // A feature with an empty name is returned if there&apos;s no feature at the given // position. rpc GetFeature(Point) returns (Feature) &#123;&#125; // A server-to-client streaming RPC. // // Obtains the Features available within the given Rectangle. Results are // streamed rather than returned at once (e.g. in a response message with a // repeated field), as the rectangle may cover a large area and contain a // huge number of features. rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125; // A client-to-server streaming RPC. // // Accepts a stream of Points on a route being traversed, returning a // RouteSummary when traversal is completed. rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125; // A Bidirectional streaming RPC. // // Accepts a stream of RouteNotes sent while a route is being traversed, // while receiving other RouteNotes (e.g. from other users). rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;&#125;// Points are represented as latitude-longitude pairs in the E7 representation// (degrees multiplied by 10**7 and rounded to the nearest integer).// Latitudes should be in the range +/- 90 degrees and longitude should be in// the range +/- 180 degrees (inclusive).message Point &#123; int32 latitude = 1; int32 longitude = 2;&#125;// A latitude-longitude rectangle, represented as two diagonally opposite// points &quot;lo&quot; and &quot;hi&quot;.message Rectangle &#123; // One corner of the rectangle. Point lo = 1; // The other corner of the rectangle. Point hi = 2;&#125;// A feature names something at a given point.//// If a feature could not be named, the name is empty.message Feature &#123; // The name of the feature. string name = 1; // The point where the feature is detected. Point location = 2;&#125;// A RouteNote is a message sent while at a given point.message RouteNote &#123; // The location from which the message is sent. Point location = 1; // The message to be sent. string message = 2;&#125;// A RouteSummary is received in response to a RecordRoute rpc.//// It contains the number of individual points received, the number of// detected features, and the total distance covered as the cumulative sum of// the distance between each point.message RouteSummary &#123; // The number of points received. int32 point_count = 1; // The number of known features passed while traversing the route. int32 feature_count = 2; // The distance covered in metres. int32 distance = 3; // The duration of the traversal in seconds. int32 elapsed_time = 4;&#125; 测试protobuf是否安装成功切换至routeguide目录运行1generate protoc -I ../routeguide --go_out=plugins=grpc:../routeguide ../routeguide/route_guide.proto 若生成route_guide.pb.go，则代表protobuf安装成功 route_guide_db.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601[&#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 407838351, &quot;longitude&quot;: -746143763 &#125;, &quot;name&quot;: &quot;Patriots Path, Mendham, NJ 07945, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 408122808, &quot;longitude&quot;: -743999179 &#125;, &quot;name&quot;: &quot;101 New Jersey 10, Whippany, NJ 07981, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 413628156, &quot;longitude&quot;: -749015468 &#125;, &quot;name&quot;: &quot;U.S. 6, Shohola, PA 18458, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 419999544, &quot;longitude&quot;: -740371136 &#125;, &quot;name&quot;: &quot;5 Conners Road, Kingston, NY 12401, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 414008389, &quot;longitude&quot;: -743951297 &#125;, &quot;name&quot;: &quot;Mid Hudson Psychiatric Center, New Hampton, NY 10958, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 419611318, &quot;longitude&quot;: -746524769 &#125;, &quot;name&quot;: &quot;287 Flugertown Road, Livingston Manor, NY 12758, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406109563, &quot;longitude&quot;: -742186778 &#125;, &quot;name&quot;: &quot;4001 Tremley Point Road, Linden, NJ 07036, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 416802456, &quot;longitude&quot;: -742370183 &#125;, &quot;name&quot;: &quot;352 South Mountain Road, Wallkill, NY 12589, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412950425, &quot;longitude&quot;: -741077389 &#125;, &quot;name&quot;: &quot;Bailey Turn Road, Harriman, NY 10926, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412144655, &quot;longitude&quot;: -743949739 &#125;, &quot;name&quot;: &quot;193-199 Wawayanda Road, Hewitt, NJ 07421, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 415736605, &quot;longitude&quot;: -742847522 &#125;, &quot;name&quot;: &quot;406-496 Ward Avenue, Pine Bush, NY 12566, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 413843930, &quot;longitude&quot;: -740501726 &#125;, &quot;name&quot;: &quot;162 Merrill Road, Highland Mills, NY 10930, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 410873075, &quot;longitude&quot;: -744459023 &#125;, &quot;name&quot;: &quot;Clinton Road, West Milford, NJ 07480, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412346009, &quot;longitude&quot;: -744026814 &#125;, &quot;name&quot;: &quot;16 Old Brook Lane, Warwick, NY 10990, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 402948455, &quot;longitude&quot;: -747903913 &#125;, &quot;name&quot;: &quot;3 Drake Lane, Pennington, NJ 08534, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406337092, &quot;longitude&quot;: -740122226 &#125;, &quot;name&quot;: &quot;6324 8th Avenue, Brooklyn, NY 11220, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406421967, &quot;longitude&quot;: -747727624 &#125;, &quot;name&quot;: &quot;1 Merck Access Road, Whitehouse Station, NJ 08889, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 416318082, &quot;longitude&quot;: -749677716 &#125;, &quot;name&quot;: &quot;78-98 Schalck Road, Narrowsburg, NY 12764, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 415301720, &quot;longitude&quot;: -748416257 &#125;, &quot;name&quot;: &quot;282 Lakeview Drive Road, Highland Lake, NY 12743, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 402647019, &quot;longitude&quot;: -747071791 &#125;, &quot;name&quot;: &quot;330 Evelyn Avenue, Hamilton Township, NJ 08619, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412567807, &quot;longitude&quot;: -741058078 &#125;, &quot;name&quot;: &quot;New York State Reference Route 987E, Southfields, NY 10975, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 416855156, &quot;longitude&quot;: -744420597 &#125;, &quot;name&quot;: &quot;103-271 Tempaloni Road, Ellenville, NY 12428, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404663628, &quot;longitude&quot;: -744820157 &#125;, &quot;name&quot;: &quot;1300 Airport Road, North Brunswick Township, NJ 08902, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 407113723, &quot;longitude&quot;: -749746483 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 402133926, &quot;longitude&quot;: -743613249 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 400273442, &quot;longitude&quot;: -741220915 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 411236786, &quot;longitude&quot;: -744070769 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 411633782, &quot;longitude&quot;: -746784970 &#125;, &quot;name&quot;: &quot;211-225 Plains Road, Augusta, NJ 07822, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 415830701, &quot;longitude&quot;: -742952812 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 413447164, &quot;longitude&quot;: -748712898 &#125;, &quot;name&quot;: &quot;165 Pedersen Ridge Road, Milford, PA 18337, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 405047245, &quot;longitude&quot;: -749800722 &#125;, &quot;name&quot;: &quot;100-122 Locktown Road, Frenchtown, NJ 08825, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 418858923, &quot;longitude&quot;: -746156790 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 417951888, &quot;longitude&quot;: -748484944 &#125;, &quot;name&quot;: &quot;650-652 Willi Hill Road, Swan Lake, NY 12783, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 407033786, &quot;longitude&quot;: -743977337 &#125;, &quot;name&quot;: &quot;26 East 3rd Street, New Providence, NJ 07974, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 417548014, &quot;longitude&quot;: -740075041 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 410395868, &quot;longitude&quot;: -744972325 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404615353, &quot;longitude&quot;: -745129803 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406589790, &quot;longitude&quot;: -743560121 &#125;, &quot;name&quot;: &quot;611 Lawrence Avenue, Westfield, NJ 07090, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 414653148, &quot;longitude&quot;: -740477477 &#125;, &quot;name&quot;: &quot;18 Lannis Avenue, New Windsor, NY 12553, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 405957808, &quot;longitude&quot;: -743255336 &#125;, &quot;name&quot;: &quot;82-104 Amherst Avenue, Colonia, NJ 07067, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 411733589, &quot;longitude&quot;: -741648093 &#125;, &quot;name&quot;: &quot;170 Seven Lakes Drive, Sloatsburg, NY 10974, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412676291, &quot;longitude&quot;: -742606606 &#125;, &quot;name&quot;: &quot;1270 Lakes Road, Monroe, NY 10950, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 409224445, &quot;longitude&quot;: -748286738 &#125;, &quot;name&quot;: &quot;509-535 Alphano Road, Great Meadows, NJ 07838, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406523420, &quot;longitude&quot;: -742135517 &#125;, &quot;name&quot;: &quot;652 Garden Street, Elizabeth, NJ 07202, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 401827388, &quot;longitude&quot;: -740294537 &#125;, &quot;name&quot;: &quot;349 Sea Spray Court, Neptune City, NJ 07753, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 410564152, &quot;longitude&quot;: -743685054 &#125;, &quot;name&quot;: &quot;13-17 Stanley Street, West Milford, NJ 07480, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 408472324, &quot;longitude&quot;: -740726046 &#125;, &quot;name&quot;: &quot;47 Industrial Avenue, Teterboro, NJ 07608, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412452168, &quot;longitude&quot;: -740214052 &#125;, &quot;name&quot;: &quot;5 White Oak Lane, Stony Point, NY 10980, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 409146138, &quot;longitude&quot;: -746188906 &#125;, &quot;name&quot;: &quot;Berkshire Valley Management Area Trail, Jefferson, NJ, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404701380, &quot;longitude&quot;: -744781745 &#125;, &quot;name&quot;: &quot;1007 Jersey Avenue, New Brunswick, NJ 08901, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 409642566, &quot;longitude&quot;: -746017679 &#125;, &quot;name&quot;: &quot;6 East Emerald Isle Drive, Lake Hopatcong, NJ 07849, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 408031728, &quot;longitude&quot;: -748645385 &#125;, &quot;name&quot;: &quot;1358-1474 New Jersey 57, Port Murray, NJ 07865, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 413700272, &quot;longitude&quot;: -742135189 &#125;, &quot;name&quot;: &quot;367 Prospect Road, Chester, NY 10918, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404310607, &quot;longitude&quot;: -740282632 &#125;, &quot;name&quot;: &quot;10 Simon Lake Drive, Atlantic Highlands, NJ 07716, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 409319800, &quot;longitude&quot;: -746201391 &#125;, &quot;name&quot;: &quot;11 Ward Street, Mount Arlington, NJ 07856, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406685311, &quot;longitude&quot;: -742108603 &#125;, &quot;name&quot;: &quot;300-398 Jefferson Avenue, Elizabeth, NJ 07201, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 419018117, &quot;longitude&quot;: -749142781 &#125;, &quot;name&quot;: &quot;43 Dreher Road, Roscoe, NY 12776, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412856162, &quot;longitude&quot;: -745148837 &#125;, &quot;name&quot;: &quot;Swan Street, Pine Island, NY 10969, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 416560744, &quot;longitude&quot;: -746721964 &#125;, &quot;name&quot;: &quot;66 Pleasantview Avenue, Monticello, NY 12701, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 405314270, &quot;longitude&quot;: -749836354 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 414219548, &quot;longitude&quot;: -743327440 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 415534177, &quot;longitude&quot;: -742900616 &#125;, &quot;name&quot;: &quot;565 Winding Hills Road, Montgomery, NY 12549, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406898530, &quot;longitude&quot;: -749127080 &#125;, &quot;name&quot;: &quot;231 Rocky Run Road, Glen Gardner, NJ 08826, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 407586880, &quot;longitude&quot;: -741670168 &#125;, &quot;name&quot;: &quot;100 Mount Pleasant Avenue, Newark, NJ 07104, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 400106455, &quot;longitude&quot;: -742870190 &#125;, &quot;name&quot;: &quot;517-521 Huntington Drive, Manchester Township, NJ 08759, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 400066188, &quot;longitude&quot;: -746793294 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 418803880, &quot;longitude&quot;: -744102673 &#125;, &quot;name&quot;: &quot;40 Mountain Road, Napanoch, NY 12458, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 414204288, &quot;longitude&quot;: -747895140 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 414777405, &quot;longitude&quot;: -740615601 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 415464475, &quot;longitude&quot;: -747175374 &#125;, &quot;name&quot;: &quot;48 North Road, Forestburgh, NY 12777, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404062378, &quot;longitude&quot;: -746376177 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 405688272, &quot;longitude&quot;: -749285130 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 400342070, &quot;longitude&quot;: -748788996 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 401809022, &quot;longitude&quot;: -744157964 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404226644, &quot;longitude&quot;: -740517141 &#125;, &quot;name&quot;: &quot;9 Thompson Avenue, Leonardo, NJ 07737, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 410322033, &quot;longitude&quot;: -747871659 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 407100674, &quot;longitude&quot;: -747742727 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 418811433, &quot;longitude&quot;: -741718005 &#125;, &quot;name&quot;: &quot;213 Bush Road, Stone Ridge, NY 12484, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 415034302, &quot;longitude&quot;: -743850945 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 411349992, &quot;longitude&quot;: -743694161 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404839914, &quot;longitude&quot;: -744759616 &#125;, &quot;name&quot;: &quot;1-17 Bergen Court, New Brunswick, NJ 08901, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 414638017, &quot;longitude&quot;: -745957854 &#125;, &quot;name&quot;: &quot;35 Oakland Valley Road, Cuddebackville, NY 12729, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412127800, &quot;longitude&quot;: -740173578 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 401263460, &quot;longitude&quot;: -747964303 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 412843391, &quot;longitude&quot;: -749086026 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 418512773, &quot;longitude&quot;: -743067823 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404318328, &quot;longitude&quot;: -740835638 &#125;, &quot;name&quot;: &quot;42-102 Main Street, Belford, NJ 07718, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 419020746, &quot;longitude&quot;: -741172328 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404080723, &quot;longitude&quot;: -746119569 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 401012643, &quot;longitude&quot;: -744035134 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 404306372, &quot;longitude&quot;: -741079661 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 403966326, &quot;longitude&quot;: -748519297 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 405002031, &quot;longitude&quot;: -748407866 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 409532885, &quot;longitude&quot;: -742200683 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 416851321, &quot;longitude&quot;: -742674555 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 406411633, &quot;longitude&quot;: -741722051 &#125;, &quot;name&quot;: &quot;3387 Richmond Terrace, Staten Island, NY 10303, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 413069058, &quot;longitude&quot;: -744597778 &#125;, &quot;name&quot;: &quot;261 Van Sickle Road, Goshen, NY 10924, USA&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 418465462, &quot;longitude&quot;: -746859398 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 411733222, &quot;longitude&quot;: -744228360 &#125;, &quot;name&quot;: &quot;&quot;&#125;, &#123; &quot;location&quot;: &#123; &quot;latitude&quot;: 410248224, &quot;longitude&quot;: -747127767 &#125;, &quot;name&quot;: &quot;3 Hasta Way, Newton, NJ 07860, USA&quot;&#125;] grpcServer.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/* * * Copyright 2015 gRPC authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * *///go:generate protoc -I ../routeguide --go_out=plugins=grpc:../routeguide ../routeguide/route_guide.proto// Package main implements a simple gRPC server that demonstrates how to use gRPC-Go libraries// to perform unary, client streaming, server streaming and full duplex RPCs.//// It implements the route guide service whose definition can be found in routeguide/route_guide.proto.package mainimport ( &quot;encoding/json&quot; &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;math&quot; &quot;net&quot; &quot;time&quot; &quot;golang.org/x/net/context&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; &quot;google.golang.org/grpc/testdata&quot; &quot;github.com/golang/protobuf/proto&quot; pb &quot;google.golang.org/grpc/examples/route_guide/routeguide&quot;)var ( tls = flag.Bool(&quot;tls&quot;, false, &quot;Connection uses TLS if true, else plain TCP&quot;) certFile = flag.String(&quot;cert_file&quot;, &quot;&quot;, &quot;The TLS cert file&quot;) keyFile = flag.String(&quot;key_file&quot;, &quot;&quot;, &quot;The TLS key file&quot;) jsonDBFile = flag.String(&quot;json_db_file&quot;, &quot;testdata/route_guide_db.json&quot;, &quot;A json file containing a list of features&quot;) port = flag.Int(&quot;port&quot;, 10000, &quot;The server port&quot;))type routeGuideServer struct &#123; savedFeatures []*pb.Feature routeNotes map[string][]*pb.RouteNote&#125;// GetFeature returns the feature at the given point.func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) &#123; for _, feature := range s.savedFeatures &#123; if proto.Equal(feature.Location, point) &#123; return feature, nil &#125; &#125; // No feature was found, return an unnamed feature return &amp;pb.Feature&#123;Location: point&#125;, nil&#125;// ListFeatures lists all features contained within the given bounding Rectangle.func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error &#123; for _, feature := range s.savedFeatures &#123; if inRange(feature.Location, rect) &#123; if err := stream.Send(feature); err != nil &#123; return err &#125; &#125; &#125; return nil&#125;// RecordRoute records a route composited of a sequence of points.//// It gets a stream of points, and responds with statistics about the &quot;trip&quot;:// number of points, number of known features visited, total distance traveled, and// total time spent.func (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error &#123; var pointCount, featureCount, distance int32 var lastPoint *pb.Point startTime := time.Now() for &#123; point, err := stream.Recv() if err == io.EOF &#123; endTime := time.Now() return stream.SendAndClose(&amp;pb.RouteSummary&#123; PointCount: pointCount, FeatureCount: featureCount, Distance: distance, ElapsedTime: int32(endTime.Sub(startTime).Seconds()), &#125;) &#125; if err != nil &#123; return err &#125; pointCount++ for _, feature := range s.savedFeatures &#123; if proto.Equal(feature.Location, point) &#123; featureCount++ &#125; &#125; if lastPoint != nil &#123; distance += calcDistance(lastPoint, point) &#125; lastPoint = point &#125;&#125;// RouteChat receives a stream of message/location pairs, and responds with a stream of all// previous messages at each of those locations.func (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error &#123; for &#123; in, err := stream.Recv() if err == io.EOF &#123; return nil &#125; if err != nil &#123; return err &#125; key := serialize(in.Location) if _, present := s.routeNotes[key]; !present &#123; s.routeNotes[key] = []*pb.RouteNote&#123;in&#125; &#125; else &#123; s.routeNotes[key] = append(s.routeNotes[key], in) &#125; for _, note := range s.routeNotes[key] &#123; if err := stream.Send(note); err != nil &#123; return err &#125; &#125; &#125;&#125;// loadFeatures loads features from a JSON file.func (s *routeGuideServer) loadFeatures(filePath string) &#123; file, err := ioutil.ReadFile(filePath) if err != nil &#123; log.Fatalf(&quot;Failed to load default features: %v&quot;, err) &#125; if err := json.Unmarshal(file, &amp;s.savedFeatures); err != nil &#123; log.Fatalf(&quot;Failed to load default features: %v&quot;, err) &#125;&#125;func toRadians(num float64) float64 &#123; return num * math.Pi / float64(180)&#125;// calcDistance calculates the distance between two points using the &quot;haversine&quot; formula.// This code was taken from http://www.movable-type.co.uk/scripts/latlong.html.func calcDistance(p1 *pb.Point, p2 *pb.Point) int32 &#123; const CordFactor float64 = 1e7 const R float64 = float64(6371000) // metres lat1 := float64(p1.Latitude) / CordFactor lat2 := float64(p2.Latitude) / CordFactor lng1 := float64(p1.Longitude) / CordFactor lng2 := float64(p2.Longitude) / CordFactor φ1 := toRadians(lat1) φ2 := toRadians(lat2) Δφ := toRadians(lat2 - lat1) Δλ := toRadians(lng2 - lng1) a := math.Sin(Δφ/2)*math.Sin(Δφ/2) + math.Cos(φ1)*math.Cos(φ2)* math.Sin(Δλ/2)*math.Sin(Δλ/2) c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a)) distance := R * c return int32(distance)&#125;func inRange(point *pb.Point, rect *pb.Rectangle) bool &#123; left := math.Min(float64(rect.Lo.Longitude), float64(rect.Hi.Longitude)) right := math.Max(float64(rect.Lo.Longitude), float64(rect.Hi.Longitude)) top := math.Max(float64(rect.Lo.Latitude), float64(rect.Hi.Latitude)) bottom := math.Min(float64(rect.Lo.Latitude), float64(rect.Hi.Latitude)) if float64(point.Longitude) &gt;= left &amp;&amp; float64(point.Longitude) &lt;= right &amp;&amp; float64(point.Latitude) &gt;= bottom &amp;&amp; float64(point.Latitude) &lt;= top &#123; return true &#125; return false&#125;func serialize(point *pb.Point) string &#123; return fmt.Sprintf(&quot;%d %d&quot;, point.Latitude, point.Longitude)&#125;func newServer() *routeGuideServer &#123; s := new(routeGuideServer) s.loadFeatures(*jsonDBFile) s.routeNotes = make(map[string][]*pb.RouteNote) return s&#125;func main() &#123; flag.Parse() lis, err := net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;localhost:%d&quot;, *port)) if err != nil &#123; log.Fatalf(&quot;failed to listen: %v&quot;, err) &#125; var opts []grpc.ServerOption if *tls &#123; if *certFile == &quot;&quot; &#123; *certFile = testdata.Path(&quot;server1.pem&quot;) &#125; if *keyFile == &quot;&quot; &#123; *keyFile = testdata.Path(&quot;server1.key&quot;) &#125; creds, err := credentials.NewServerTLSFromFile(*certFile, *keyFile) if err != nil &#123; log.Fatalf(&quot;Failed to generate credentials %v&quot;, err) &#125; opts = []grpc.ServerOption&#123;grpc.Creds(creds)&#125; &#125; grpcServer := grpc.NewServer(opts...) pb.RegisterRouteGuideServer(grpcServer, newServer()) grpcServer.Serve(lis)&#125; grpcClient.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/* * * Copyright 2015 gRPC authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */// Package main implements a simple gRPC client that demonstrates how to use gRPC-Go libraries// to perform unary, client streaming, server streaming and full duplex RPCs.//// It interacts with the route guide service whose definition can be found in routeguide/route_guide.proto.package mainimport ( &quot;flag&quot; &quot;io&quot; &quot;log&quot; &quot;math/rand&quot; &quot;time&quot; &quot;golang.org/x/net/context&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; pb &quot;google.golang.org/grpc/examples/route_guide/routeguide&quot; &quot;google.golang.org/grpc/testdata&quot;)var ( tls = flag.Bool(&quot;tls&quot;, false, &quot;Connection uses TLS if true, else plain TCP&quot;) caFile = flag.String(&quot;ca_file&quot;, &quot;&quot;, &quot;The file containning the CA root cert file&quot;) serverAddr = flag.String(&quot;server_addr&quot;, &quot;127.0.0.1:10000&quot;, &quot;The server address in the format of host:port&quot;) serverHostOverride = flag.String(&quot;server_host_override&quot;, &quot;x.test.youtube.com&quot;, &quot;The server name use to verify the hostname returned by TLS handshake&quot;))// printFeature gets the feature for the given point.func printFeature(client pb.RouteGuideClient, point *pb.Point) &#123; log.Printf(&quot;Getting feature for point (%d, %d)&quot;, point.Latitude, point.Longitude) feature, err := client.GetFeature(context.Background(), point) if err != nil &#123; log.Fatalf(&quot;%v.GetFeatures(_) = _, %v: &quot;, client, err) &#125; log.Println(feature)&#125;// printFeatures lists all the features within the given bounding Rectangle.func printFeatures(client pb.RouteGuideClient, rect *pb.Rectangle) &#123; log.Printf(&quot;Looking for features within %v&quot;, rect) stream, err := client.ListFeatures(context.Background(), rect) if err != nil &#123; log.Fatalf(&quot;%v.ListFeatures(_) = _, %v&quot;, client, err) &#125; for &#123; feature, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Fatalf(&quot;%v.ListFeatures(_) = _, %v&quot;, client, err) &#125; log.Println(feature) &#125;&#125;// runRecordRoute sends a sequence of points to server and expects to get a RouteSummary from server.func runRecordRoute(client pb.RouteGuideClient) &#123; // Create a random number of random points r := rand.New(rand.NewSource(time.Now().UnixNano())) pointCount := int(r.Int31n(100)) + 2 // Traverse at least two points var points []*pb.Point for i := 0; i &lt; pointCount; i++ &#123; points = append(points, randomPoint(r)) &#125; log.Printf(&quot;Traversing %d points.&quot;, len(points)) stream, err := client.RecordRoute(context.Background()) if err != nil &#123; log.Fatalf(&quot;%v.RecordRoute(_) = _, %v&quot;, client, err) &#125; for _, point := range points &#123; if err := stream.Send(point); err != nil &#123; log.Fatalf(&quot;%v.Send(%v) = %v&quot;, stream, point, err) &#125; &#125; reply, err := stream.CloseAndRecv() if err != nil &#123; log.Fatalf(&quot;%v.CloseAndRecv() got error %v, want %v&quot;, stream, err, nil) &#125; log.Printf(&quot;Route summary: %v&quot;, reply)&#125;// runRouteChat receives a sequence of route notes, while sending notes for various locations.func runRouteChat(client pb.RouteGuideClient) &#123; notes := []*pb.RouteNote&#123; &#123;&amp;pb.Point&#123;Latitude: 0, Longitude: 1&#125;, &quot;First message&quot;&#125;, &#123;&amp;pb.Point&#123;Latitude: 0, Longitude: 2&#125;, &quot;Second message&quot;&#125;, &#123;&amp;pb.Point&#123;Latitude: 0, Longitude: 3&#125;, &quot;Third message&quot;&#125;, &#123;&amp;pb.Point&#123;Latitude: 0, Longitude: 1&#125;, &quot;Fourth message&quot;&#125;, &#123;&amp;pb.Point&#123;Latitude: 0, Longitude: 2&#125;, &quot;Fifth message&quot;&#125;, &#123;&amp;pb.Point&#123;Latitude: 0, Longitude: 3&#125;, &quot;Sixth message&quot;&#125;, &#125; stream, err := client.RouteChat(context.Background()) if err != nil &#123; log.Fatalf(&quot;%v.RouteChat(_) = _, %v&quot;, client, err) &#125; waitc := make(chan struct&#123;&#125;) go func() &#123; for &#123; in, err := stream.Recv() if err == io.EOF &#123; // read done. close(waitc) return &#125; if err != nil &#123; log.Fatalf(&quot;Failed to receive a note : %v&quot;, err) &#125; log.Printf(&quot;Got message %s at point(%d, %d)&quot;, in.Message, in.Location.Latitude, in.Location.Longitude) &#125; &#125;() for _, note := range notes &#123; if err := stream.Send(note); err != nil &#123; log.Fatalf(&quot;Failed to send a note: %v&quot;, err) &#125; &#125; stream.CloseSend() &lt;-waitc&#125;func randomPoint(r *rand.Rand) *pb.Point &#123; lat := (r.Int31n(180) - 90) * 1e7 long := (r.Int31n(360) - 180) * 1e7 return &amp;pb.Point&#123;Latitude: lat, Longitude: long&#125;&#125;func main() &#123; flag.Parse() var opts []grpc.DialOption if *tls &#123; if *caFile == &quot;&quot; &#123; *caFile = testdata.Path(&quot;ca.pem&quot;) &#125; creds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride) if err != nil &#123; log.Fatalf(&quot;Failed to create TLS credentials %v&quot;, err) &#125; opts = append(opts, grpc.WithTransportCredentials(creds)) &#125; else &#123; opts = append(opts, grpc.WithInsecure()) &#125; conn, err := grpc.Dial(*serverAddr, opts...) if err != nil &#123; log.Fatalf(&quot;fail to dial: %v&quot;, err) &#125; defer conn.Close() client := pb.NewRouteGuideClient(conn) // Looking for a valid feature printFeature(client, &amp;pb.Point&#123;Latitude: 409146138, Longitude: -746188906&#125;) // Feature missing. printFeature(client, &amp;pb.Point&#123;Latitude: 0, Longitude: 0&#125;) // Looking for features between 40, -75 and 42, -73. printFeatures(client, &amp;pb.Rectangle&#123; Lo: &amp;pb.Point&#123;Latitude: 400000000, Longitude: -750000000&#125;, Hi: &amp;pb.Point&#123;Latitude: 420000000, Longitude: -730000000&#125;, &#125;) // RecordRoute runRecordRoute(client) // RouteChat runRouteChat(client)&#125; 最后分别到server和client目录下，执行12go run grpcServer.gogo run grpcClient.go","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"grpc","slug":"grpc","permalink":"http://yoursite.com/tags/grpc/"},{"name":"protobuf","slug":"protobuf","permalink":"http://yoursite.com/tags/protobuf/"}]},{"title":"一些生活的随笔","slug":"一些生活的随笔","date":"2017-08-20T14:51:00.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2017/08/20/一些生活的随笔/","link":"","permalink":"http://yoursite.com/2017/08/20/一些生活的随笔/","excerpt":"","text":"1、这段时间开始减肥，每天锻炼身体，一般是腹肌撕裂者加跑步，然后饮食少油，瘦了一些，腹肌也出来了。2、这周给同事做了关于redis的分享，关于redis，我是从去年开始了解的，首先是学会redis的基本使用，接着了解了redis在目前的项目中有哪些运用，然后看了redis的书籍及源码，最后到了现在给同事分享关于redis的东西，主要是介绍了redis的数据结构及编码、数据持久化、网络封装、集群与主从，以及为什么要使用reids这些方面。这也是我职业生涯中第一次做分享，虽然有些地方讲述的不够好，但是也算是一个小小的突破，希望自己能再接再厉。3、这两周周末一些高中、大学玩的很好的同学老找我，感觉到了有时候有一些很好的朋友，能够聊聊生活，聊聊人生也是一件很幸福的事。4、这周买了很多厨房的东西，开始自己弄饭了，弄了咖喱鸡、牛肉面、鸡排，感觉自己弄得还是挺健康的，也好吃，让生活变得很有质感，这就很好。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"关于golang关键字defer","slug":"关于golang关键字defer","date":"2017-04-07T14:06:45.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2017/04/07/关于golang关键字defer/","link":"","permalink":"http://yoursite.com/2017/04/07/关于golang关键字defer/","excerpt":"0、看先官方文档怎么说：Defer statementsA “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.","text":"0、看先官方文档怎么说：Defer statementsA “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. DeferStmt = “defer” Expression .The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements. Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the “defer” statement is executed. For instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes. (See also the section on handling panics.) 1 、最基础的文件关闭，解锁,调用顺序等12345f,err := os.Open(filename)if err != nil &#123; panic(err)&#125;defer f.Close() 123mu.Lock()doSomething();defer mu.Unlock() 如果有多个defer表达式，调用顺序类似于栈，越后面的defer表达式越先被调用。123456func f() &#123; for i := 0; i &lt; 4; i++ &#123; defer fmt.Print(i) &#125;&#125;//输出3210 2、defer的坑1）123456func f() (result int) &#123; defer func() &#123; result++ &#125;() return 0&#125; 2）1234567func f() (r int) &#123; t := 2 defer func() &#123; t = t + 2 &#125;() return t&#125; 3）123456func f() (r int) &#123; defer func(r int) &#123; r = r + 5 &#125;(r) return 1&#125; 4）123456func a() &#123; i := 0 defer fmt.Println(i) i++ return&#125; 结果是第一个为1，第二个为2，第三个为1，第四个为输出0原因是defer是在return之前执行的，并且return 语句不是原子的函数返回过程：先给返回值赋值，然后调用defer表达式，最后返回到调用函数/方法之中想得出defer正确的返回结果，只需要在心中把函数/方法改下一下就可以了，改写规则如下123返回值 = xxx调用deferred函数空的return 把上面前三个例子改写一下1）1234567func f() (result int) &#123; result = 0 defer func() &#123; result++ &#125;() return&#125; 2）12345678func f() (r int) &#123; t := 2 r = t defer func() &#123; t = t + 2 &#125;() return&#125; 3）1234567func f() (r int) &#123; r = 1 defer func(r int) &#123; //注意这里是形参 r = r + 5 &#125;(r) return&#125; 如果将第三个改写一下为123456func f() (r int) &#123; defer func() &#123; r = r + 5 &#125;() return 1&#125; 那么可以重写为1234567func f() (r int) &#123; //这样就返回的是6了 r = 1 defer func() &#123; r = r + 5 &#125;() return&#125; 3、defer的实现defer关键字的实现跟go关键字很类似，不同的是它调用的是runtime.deferproc而不是runtime.newproc。在defer出现的地方，插入了指令call runtime.deferproc，然后在函数返回之前的地方，插入指令call runtime.deferreturn。普通的函数返回时，汇编代码类似：12add xx SPreturn 如果其中包含了defer语句，则汇编代码是：123call runtime.deferreturn，add xx SPreturn goroutine的控制结构中，有一张表记录defer，调用runtime.deferproc时会将需要defer的表达式记录在表中，而在调用runtime.deferreturn的时候，则会依次从defer表中出栈并执行。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"关于重放攻击的初步学习","slug":"关于重放攻击的初步学习","date":"2016-12-17T13:24:01.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/12/17/关于重放攻击的初步学习/","link":"","permalink":"http://yoursite.com/2016/12/17/关于重放攻击的初步学习/","excerpt":"最近由于工作上的一些原因，需要使用到CMQ（Cloud Message Queue）服务，遂到官网查看相关文档，对其公共请求参数有一点疑惑。","text":"最近由于工作上的一些原因，需要使用到CMQ（Cloud Message Queue）服务，遂到官网查看相关文档，对其公共请求参数有一点疑惑。 公共请求参数如下 action 很好理解，比如CreateQueue、GetQueueAttributes、SetQueueAttributes、DeleteQueue等等; region 是对应某个地区做相应的网络优化，比如服务器在上海，选择sh，相应的网络也会好些; timestamp 为了安全性，计算签名等; secretid 密钥; signnature 一般的流程都是拿参数的key，value 排个序，然后加上密钥，最后生成一下signnature以判断数据的合法性; Nonce 这是我有一些疑问的，描述说这个与timestamp联合起来防止重放攻击的，那重放攻击是什么？ wiki定义如下：A replay attack (also known as playback attack) is a form of network attack in which a valid data transmission is maliciously or fraudulently repeated or delayed. This is carried out either by the originator or by an adversary who intercepts the data and re-transmits it, possibly as part of a masquerade attack by IP packet substitution. 简单的解释就是攻击者拿了发送者的IP包伪装成发送者获得服务器的数据。 举个例子：Suppose Alice wants to prove her identity to Bob. Bob requests her password as proof of identity, which Alice dutifully provides (possibly after some transformation like a hash function); meanwhile, Eve is eavesdropping on the conversation and keeps the password (or the hash). After the interchange is over, Eve (posing as Alice) connects to Bob; when asked for a proof of identity, Eve sends Alice’s password (or hash) read from the last session which Bob accepts, thus granting Eve access. Alice是客户端，Bob是验证服务器，Eve是窃听者。Alice向Bob发送密码时（或者被hash过后的密码）被Eve窃取到了。然后下次Eve假装自己是Alice并向Bob发送Alice的密码，以获得数据。 General Countermeasure for all Replay attacksReplay attacks can be prevented by tagging each encrypted component with a sessionid and a component number. Using this combination of solutions does not use anything that is interdependent on one another. Because there is no interdependency there is less vulnerabilities. This works because a unique, random session id is created for each run of the program thus run to run becomes more difficult to replicate. In this case an attacker would be unable to perform the replay because on a new run the session id would have changed.一般来说用sessionid和component number防止重放攻击 More on Session IdsSession ids, also known as session tokens, are one mechanism that can be used to help avoid replay attacks. The way generating a session id works is as follows. Bob sends a one-time token to Alice, which Alice uses to transform the password and send the result to Bob. For example she would use the token to compute a hash function of the session token and append it to the password to be used. On his side Bob performs the same computation with the session token. If and only if both Alice’s and Bob’s values match, the login is successful. Now suppose an attacker Eve has captured this value and tries to use it on another session. Bob would send a different session token, and when Eve replies with her captured value it will be different from Bob’s computation so he will known it is not Alice. Session tokens should be chosen by a random process (usually, pseudorandom processes are used). Otherwise Eve may be able to pose as Bob, presenting some predicted future token, and convince Alice to use that token in her transformation. Eve can then replay her reply at a later time (when the previously predicted token is actually presented by Bob), and Bob will accept the authentication. 上面的意思其实就是使用非对称密钥，也就是各大网站从http到https中的s One-time PasswordsOne-time passwords are similar to session tokens in that the password expires after it has been used or after a very short amount of time. They can be used to authenticate individual transactions in addition to sessions. These can also be used during the authentication process to help establish trust between the two parties that are communicating with each other.一次性密码，就比如手机接受的验证码，也是可以防止重放攻击的。 Nonces and MACBob can also send nonces but should then include a message authentication code (MAC), which Alice should check.随机数和message authentication code TimestampsTimestamping is another way of preventing a replay attack. Synchronization should be achieved using a secure protocol. For example Bob periodically broadcasts the time on his clock together with a MAC. When Alice wants to send Bob a message, she includes her best estimate of the time on his clock in her message, which is also authenticated. Bob only accepts messages for which the timestamp is within a reasonable tolerance. The advantage of this scheme is that Bob does not need to generate (pseudo-) random numbers, with the trade-off being that replay attacks, if they are performed quickly enough i.e. within that ‘reasonable’ limit, could succeed. 时间戳也是一个防止重放攻击的好方法","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"Factory","slug":"Factory","date":"2016-11-28T14:25:39.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/11/28/Factory/","link":"","permalink":"http://yoursite.com/2016/11/28/Factory/","excerpt":"Definition: A utility class that creates an instance of several families of classes. It can also return a factory for a certain group.","text":"Definition: A utility class that creates an instance of several families of classes. It can also return a factory for a certain group. The Factory Design Pattern is useful in a situation that requires the creation of many different types of objects, all derived from a common base type. The Factory Method defines a method for creating the objects, which subclasses can then override to specify the derived type that will be created. Thus, at run time, the Factory Method can be passed a description of a desired object (e.g., a string read from user input) and return a base class pointer to a new instance of that object. The pattern works best when a well-designed interface is used for the base class, so there is no need to cast the returned object. Problem We want to decide at run time what object is to be created based on some configuration or application parameter. When we write the code, we do not know what class should be instantiated. Solution Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;memory&gt;using namespace std;class Hamburg&#123;public: virtual double getPrice() const = 0; virtual ~Hamburg() &#123;&#125;;&#125;;class ChickenHamburg :public Hamburg&#123;public: double getPrice() const &#123; return 10; &#125; virtual ~ChickenHamburg()&#123;&#125;&#125;;class BeefHamburg :public Hamburg&#123;public: double getPrice() const &#123; return 15; &#125; virtual ~BeefHamburg()&#123;&#125;&#125;;class HamburgFactory&#123;public: enum HamburgType &#123; Chicken, Beef &#125;; static unique_ptr&lt;Hamburg&gt; getHamhury(HamburgFactory::HamburgType hamburgType) &#123; switch (hamburgType) &#123; case HamburgFactory::Chicken: return make_unique&lt;ChickenHamburg&gt;(); case HamburgFactory::Beef: return make_unique&lt;BeefHamburg&gt;(); default: break; &#125; throw \"invalid hamburg type.\"; &#125;&#125;;void hamburg_information(HamburgFactory::HamburgType hamburgType)&#123; unique_ptr&lt;Hamburg&gt; hamburg = HamburgFactory::getHamhury(hamburgType); cout &lt;&lt; \"Hamburg of \" &lt;&lt; hamburgType &lt;&lt; \" is \" &lt;&lt; hamburg-&gt;getPrice() &lt;&lt; endl;&#125;int main()&#123; hamburg_information(HamburgFactory::Chicken); hamburg_information(HamburgFactory::Beef); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Builder","slug":"Builder","date":"2016-11-16T13:47:21.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/11/16/Builder/","link":"","permalink":"http://yoursite.com/2016/11/16/Builder/","excerpt":"很久没写博客了，最近开始会写一些关于设计模式的文章，其实很多的设计模式以前就早已见过，只是以前不知道这些东西叫做设计模式，比如C++的标准库里就大量用到了设计模式，觉得很有必要学习一些。","text":"很久没写博客了，最近开始会写一些关于设计模式的文章，其实很多的设计模式以前就早已见过，只是以前不知道这些东西叫做设计模式，比如C++的标准库里就大量用到了设计模式，觉得很有必要学习一些。 BuilderThe Builder Creational Pattern is used to separate the construction of a complex object from its representation so that the same construction process can create different objects representations. ProblemWe want to construct a complex object, however we do not want to have a complex constructor member or one that would need many arguments. SolutionDefine an intermediate object whose member functions define the desired object part by part before the object is available to the client. Builder Pattern lets us defer the construction of the object until all the options for creation have been specified. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;string&gt;#include&lt;memory&gt;#include&lt;iostream&gt;using namespace std;class Hamburg&#123;private: string m_meat; string m_vegetable;public: void open() &#123; cout &lt;&lt; \"Hamburg with \" &lt;&lt; m_meat &lt;&lt; \",\" &lt;&lt; m_vegetable &lt;&lt; \".\" &lt;&lt; endl; &#125; void setMeat(string meat) &#123; m_meat = meat; &#125; void setVegetable(string vegetable) &#123; m_vegetable = vegetable; &#125;&#125;;class HamburgBuilder&#123;protected: unique_ptr&lt;Hamburg&gt; m_Hamburg;public: virtual ~HamburgBuilder() &#123;&#125;; Hamburg* getHamburg() &#123; return m_Hamburg.get(); &#125; void createNewHamburg() &#123; m_Hamburg = make_unique&lt;Hamburg&gt;(); &#125; virtual void buildMeat() = 0; virtual void buildVegetable() = 0;&#125;;class AHamburgBuilder :public HamburgBuilder&#123;public: virtual ~AHamburgBuilder()&#123;&#125; void buildMeat() &#123; m_Hamburg-&gt;setMeat(\"chicken\"); &#125; void buildVegetable() &#123; m_Hamburg-&gt;setVegetable(\"tomato\"); &#125;&#125;;class BHamburgBuilder :public HamburgBuilder&#123;public: virtual ~BHamburgBuilder()&#123;&#125; void buildMeat() &#123; m_Hamburg-&gt;setMeat(\"beef\"); &#125; void buildVegetable() &#123; m_Hamburg-&gt;setVegetable(\"carrot\"); &#125;&#125;;class Cook&#123;private: HamburgBuilder* m_HamburgBuilder;public: void makeHamburg(HamburgBuilder* pHamburgBuilder) &#123; m_HamburgBuilder = pHamburgBuilder; m_HamburgBuilder-&gt;createNewHamburg(); m_HamburgBuilder-&gt;buildMeat(); m_HamburgBuilder-&gt;buildVegetable(); &#125; void openHamburg() &#123; m_HamburgBuilder-&gt;getHamburg()-&gt;open(); &#125;&#125;;int main()&#123; Cook cook; AHamburgBuilder aHamburgBuilder; BHamburgBuilder bHamburgBuilder; cook.makeHamburg(&amp;aHamburgBuilder); cook.openHamburg(); cook.makeHamburg(&amp;bHamburgBuilder); cook.openHamburg(); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"关于智能指针源码的学习_下","slug":"关于智能指针源码的学习_下","date":"2016-09-13T14:11:11.000Z","updated":"2017-12-07T14:59:32.000Z","comments":true,"path":"2016/09/13/关于智能指针源码的学习_下/","link":"","permalink":"http://yoursite.com/2016/09/13/关于智能指针源码的学习_下/","excerpt":"这一篇是关于gcc中的智能指针： 我使用的是/usr/include/c++/4.8.2/bits/shared_ptr.h和/usr/include/c++/4.8.2/bits/shared_ptr_base.h","text":"这一篇是关于gcc中的智能指针： 我使用的是/usr/include/c++/4.8.2/bits/shared_ptr.h和/usr/include/c++/4.8.2/bits/shared_ptr_base.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859template&lt;&gt; class _Mutex_base&lt;_S_mutex&gt; : public __gnu_cxx::__mutex //和VC++不同，这里继承了__mutex &#123; protected: // This policy is used when atomic builtins are not available. // The replacement atomic operations might not have the necessary // memory barriers. enum &#123; _S_need_barriers = 1 &#125;; &#125;;template&lt;_Lock_policy _Lp = __default_lock_policy&gt; class _Sp_counted_base //自旋锁的基类，这个也是VC++没有的 : public _Mutex_base&lt;_Lp&gt; &#123; public: _Sp_counted_base() noexcept : _M_use_count(1), _M_weak_count(1) &#123; &#125; virtual ~_Sp_counted_base() noexcept &#123; &#125; // Called when _M_use_count drops to zero, to release the resources // managed by *this. virtual void _M_dispose() noexcept = 0; // Called when _M_weak_count drops to zero. virtual void _M_destroy() noexcept &#123; delete this; &#125; virtual void* _M_get_deleter(const std::type_info&amp;) = 0; void _M_add_ref_copy() &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); &#125;//……限于篇幅，只列了一部分long _M_get_use_count() const noexcept &#123; // No memory barrier is used here so there is no synchronization // with other threads. //一样的原子操作 return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED); &#125; private: _Sp_counted_base(_Sp_counted_base const&amp;) = delete; _Sp_counted_base&amp; operator=(_Sp_counted_base const&amp;) = delete; _Atomic_word _M_use_count; // #shared _Atomic_word _M_weak_count; // #weak + (#shared != 0) &#125;; 然后定义了一个__shared_ptr类，真正的shared_ptr类会继承这个类 123456789101112131415161718192021222324252627282930313233template&lt;typename _Tp, _Lock_policy _Lp&gt; class __shared_ptr &#123; public: typedef _Tp element_type; constexpr __shared_ptr() noexcept : _M_ptr(0), _M_refcount() &#123; &#125; template&lt;typename _Tp1&gt; explicit __shared_ptr(_Tp1* __p) : _M_ptr(__p), _M_refcount(__p) &#123; __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) static_assert( sizeof(_Tp1) &gt; 0, \"incomplete type\" ); __enable_shared_from_this_helper(_M_refcount, __p, __p); &#125; private: void* _M_get_deleter(const std::type_info&amp; __ti) const noexcept &#123; return _M_refcount._M_get_deleter(__ti); &#125; template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr; template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr; template&lt;typename _Del, typename _Tp1, _Lock_policy _Lp1&gt; friend _Del* get_deleter(const __shared_ptr&lt;_Tp1, _Lp1&gt;&amp;) noexcept; //基本上和VC++的大体框架还是差不多的（容器的指针以及引用计数的模版类） _Tp* _M_ptr; // Contained pointer. __shared_count&lt;_Lp&gt; _M_refcount; // Reference counter. &#125;; 接来下是__weak_ptr，真正的weak_ptr的基类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 template&lt;typename _Tp, _Lock_policy _Lp&gt; class __weak_ptr &#123; public: typedef _Tp element_type; constexpr __weak_ptr() noexcept : _M_ptr(0), _M_refcount() &#123; &#125; __weak_ptr(const __weak_ptr&amp;) noexcept = default; __weak_ptr&amp; operator=(const __weak_ptr&amp;) noexcept = default; ~__weak_ptr() = default; __shared_ptr&lt;_Tp, _Lp&gt; lock() const noexcept &#123;#ifdef __GTHREADS // Optimization: avoid throw overhead. if (expired()) return __shared_ptr&lt;element_type, _Lp&gt;(); __try &#123; return __shared_ptr&lt;element_type, _Lp&gt;(*this); &#125; __catch(const bad_weak_ptr&amp;) &#123; // Q: How can we get here? // A: Another thread may have invalidated r after the // use_count test above. return __shared_ptr&lt;element_type, _Lp&gt;(); &#125;#else // Optimization: avoid try/catch overhead when single threaded. return expired() ? __shared_ptr&lt;element_type, _Lp&gt;() : __shared_ptr&lt;element_type, _Lp&gt;(*this);#endif &#125; // XXX MT long use_count() const noexcept &#123; return _M_refcount._M_get_use_count(); &#125; bool expired() const noexcept &#123; return _M_refcount._M_get_use_count() == 0; &#125; private: // Used by __enable_shared_from_this. void _M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount) noexcept &#123; _M_ptr = __ptr; _M_refcount = __refcount; &#125; template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr; template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr; friend class __enable_shared_from_this&lt;_Tp, _Lp&gt;; friend class enable_shared_from_this&lt;_Tp&gt;; _Tp* _M_ptr; // Contained pointer. __weak_count&lt;_Lp&gt; _M_refcount; // Reference counter. &#125;; 真正的shared_ptr和weak_ptr在shared_ptr.h里面，和以前看STL源码一样，较为复杂的实现在_base.h 里面，然后实现在.h里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 template&lt;typename _Tp&gt; class shared_ptr : public __shared_ptr&lt;_Tp&gt; &#123; public: /** * @brief Construct an empty %shared_ptr. * @post use_count()==0 &amp;&amp; get()==0 */ constexpr shared_ptr() noexcept : __shared_ptr&lt;_Tp&gt;() &#123; &#125; shared_ptr(const shared_ptr&amp;) noexcept = default; //……限于篇幅，只列了一部分private: template&lt;typename _Tp1, typename _Alloc, typename... _Args&gt; friend shared_ptr&lt;_Tp1&gt; allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args); &#125;; */ template&lt;typename _Tp&gt; class weak_ptr : public __weak_ptr&lt;_Tp&gt; &#123; public: constexpr weak_ptr() noexcept : __weak_ptr&lt;_Tp&gt;() &#123; &#125; template&lt;typename _Tp1, typename = typename std::enable_if&lt;std::is_convertible&lt;_Tp1*, _Tp*&gt;::value&gt;::type&gt; weak_ptr(const weak_ptr&lt;_Tp1&gt;&amp; __r) noexcept : __weak_ptr&lt;_Tp&gt;(__r) &#123; &#125; shared_ptr&lt;_Tp&gt; lock() const noexcept &#123;#ifdef __GTHREADS if (this-&gt;expired()) return shared_ptr&lt;_Tp&gt;(); __try &#123; return shared_ptr&lt;_Tp&gt;(*this); &#125; __catch(const bad_weak_ptr&amp;) &#123; return shared_ptr&lt;_Tp&gt;(); &#125;#else return this-&gt;expired() ? shared_ptr&lt;_Tp&gt;() : shared_ptr&lt;_Tp&gt;(*this);#endif &#125; &#125;; 把一些关键的代码看了一下，也算是解了个大概，还是需要大量的实践经验才能融会贯通。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"关于智能指针源码的学习_上","slug":"关于智能指针源码的学习_上","date":"2016-09-07T14:46:22.000Z","updated":"2017-12-07T14:58:41.000Z","comments":true,"path":"2016/09/07/关于智能指针源码的学习_上/","link":"","permalink":"http://yoursite.com/2016/09/07/关于智能指针源码的学习_上/","excerpt":"以前实习面微信组的时候被面试官问到了智能指针的实现，当时只回答了一部分，面试官不是很满意，现在自己分析一下源码，加强这部分的学习。","text":"以前实习面微信组的时候被面试官问到了智能指针的实现，当时只回答了一部分，面试官不是很满意，现在自己分析一下源码，加强这部分的学习。这一篇是关于微软的Visual C++中的智能指针 :我用的是Microsoft Visual Studio 12.0\\VC\\crt\\src\\memory 12345678910111213141516 // CLASS bad_weak_ptr //当程序有异常的时候使用e.what()来查看异常 //不过C++和java/C#不同的一点是，C++是不鼓励异常的，毕竟影响效率class bad_weak_ptr : public _XSTD exception &#123; // exception type for invalid use of expired weak_ptr objectpublic: explicit bad_weak_ptr(const char * = 0) _NOEXCEPT &#123; // construct with ignored message &#125; virtual const char *__CLR_OR_THIS_CALL what() const throw() &#123; // return pointer to message string return (\"bad_weak_ptr\"); &#125; &#125;; 一个shared_ptr大概长这样下面是其中_Ref_count的基类_Ref_count_base12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// CLASS _Ref_count_baseclass _Ref_count_base &#123; // common code for reference countingprivate: virtual void _Destroy() = 0; virtual void _Delete_this() = 0;private: _Atomic_counter_t _Uses; _Atomic_counter_t _Weaks;protected: _Ref_count_base() //原子操作 &#123; // construct _Init_atomic_counter(_Uses, 1); _Init_atomic_counter(_Weaks, 1); &#125;public: virtual ~_Ref_count_base() _NOEXCEPT //虚析构防止内存泄漏 &#123; // ensure that derived classes can be destroyed properly &#125; bool _Incref_nz() &#123; // increment use count if not zero, return true if successful for (; ; ) &#123; // loop until state is known //不同平台有不同的实现原子自增的方式 #if defined(_M_IX86) || defined(_M_X64) || defined(_M_CEE_PURE) _Atomic_integral_t _Count = static_cast&lt;volatile _Atomic_counter_t&amp;&gt;(_Uses); if (_Count == 0) return (false); if (static_cast&lt;_Atomic_integral_t&gt;(_InterlockedCompareExchange( reinterpret_cast&lt;volatile long *&gt;(&amp;_Uses), _Count + 1, _Count)) == _Count) return (true); #else /* defined(_M_IX86) || defined(_M_X64) || defined(_M_CEE_PURE) */ _Atomic_integral_t _Count = _Load_atomic_counter(_Uses); if (_Count == 0) return (false); if (_Compare_increment_atomic_counter(_Uses, _Count)) return (true); #endif /* defined(_M_IX86) || defined(_M_X64) || defined(_M_CEE_PURE) */ &#125; &#125; unsigned int _Get_uses() const &#123; // return use count return (_Get_atomic_count(_Uses)); &#125; void _Incref() &#123; // increment use count _MT_INCR(_Mtx, _Uses); &#125; void _Incwref() &#123; // increment weak reference count _MT_INCR(_Mtx, _Weaks); &#125; void _Decref() &#123; // decrement use count if (_MT_DECR(_Mtx, _Uses) == 0) &#123; // destroy managed resource, decrement weak reference count _Destroy(); _Decwref(); &#125; &#125; void _Decwref() &#123; // decrement weak reference count if (_MT_DECR(_Mtx, _Weaks) == 0) _Delete_this(); &#125; long _Use_count() const &#123; // return use count return (_Get_uses()); &#125; bool _Expired() const //判断是否失效 &#123; // return true if _Uses == 0 return (_Get_uses() == 0); &#125; virtual void *_Get_deleter(const _XSTD2 type_info&amp;) const &#123; // return address of deleter object return (0); &#125; &#125;; 然后是图中的_Ref_count123456789101112131415161718192021222324// TEMPLATE CLASS _Ref_counttemplate&lt;class _Ty&gt; class _Ref_count : public _Ref_count_base &#123; // handle reference counting for object without deleterpublic: _Ref_count(_Ty *_Px) : _Ref_count_base(), _Ptr(_Px) &#123; // construct &#125;private: virtual void _Destroy() &#123; // destroy managed resource delete _Ptr; &#125; virtual void _Delete_this() &#123; // destroy self delete this; &#125; _Ty * _Ptr; &#125;; 其中_Ty的定义如下 12345678910111213141516171819202122232425262728293031 // TEMPLATE CLASS _Ref_count_deltemplate&lt;class _Ty, class _Dx&gt; class _Ref_count_del : public _Ref_count_base &#123; // handle reference counting for object with deleterpublic: _Ref_count_del(_Ty *_Px, _Dx _Dt) : _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt) &#123; // construct &#125; virtual void *_Get_deleter(const _XSTD2 type_info&amp; _Typeid) const &#123; // return address of deleter object return ((void *)(_Typeid == typeid(_Dx) ? &amp;_Dtor : 0)); &#125;private: virtual void _Destroy() &#123; // destroy managed resource _Dtor(_Ptr); &#125; virtual void _Delete_this() &#123; // destroy self delete this; &#125; _Ty * _Ptr; _Dx _Dtor; // the stored destructor for the controlled object &#125;; 接下来是shared_ptr和weak_ptr的基类 _Ptr_base 123456789101112131415161718192021222324252627// TEMPLATE CLASS _Ptr_basetemplate&lt;class _Ty&gt; class _Ptr_base &#123; // base class for shared_ptr and weak_ptrpublic: typedef _Ptr_base&lt;_Ty&gt; _Myt; typedef _Ty element_type; _Ptr_base() : _Ptr(0), _Rep(0) &#123; // construct &#125; _Ptr_base(_Myt&amp;&amp; _Right) //注意这里是右值 : _Ptr(0), _Rep(0) &#123; // construct _Ptr_base object that takes resource from _Right _Assign_rv(_STD forward&lt;_Myt&gt;(_Right)); &#125; //……限于篇幅，只列了一部分private: _Ty *_Ptr; _Ref_count_base *_Rep; template&lt;class _Ty0&gt; friend class _Ptr_base; &#125;; 接下来是非常重要的shared_ptr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// TEMPLATE CLASS shared_ptrtemplate&lt;class _Ty&gt; class shared_ptr : public _Ptr_base&lt;_Ty&gt; &#123; // class for reference counted resource managementpublic: typedef shared_ptr&lt;_Ty&gt; _Myt; typedef _Ptr_base&lt;_Ty&gt; _Mybase; shared_ptr() _NOEXCEPT &#123; // construct empty shared_ptr &#125; template&lt;class _Ux&gt; explicit shared_ptr(_Ux *_Px) &#123; // construct shared_ptr object that owns _Px _Resetp(_Px); &#125; template&lt;class _Ux, class _Dx&gt; shared_ptr(_Ux *_Px, _Dx _Dt) &#123; // construct with _Px, deleter _Resetp(_Px, _Dt); &#125; shared_ptr(nullptr_t) &#123; // construct empty shared_ptr &#125;private: template&lt;class _Ux&gt; void _Resetp(_Ux *_Px) &#123; // release, take ownership of _Px _TRY_BEGIN // allocate control block and reset _Resetp0(_Px, new _Ref_count&lt;_Ux&gt;(_Px)); _CATCH_ALL // allocation failed, delete resource delete _Px; _RERAISE; _CATCH_END &#125; template&lt;class _Ux, class _Dx&gt; void _Resetp(_Ux *_Px, _Dx _Dt) &#123; // release, take ownership of _Px, deleter _Dt _TRY_BEGIN // allocate control block and reset _Resetp0(_Px, new _Ref_count_del&lt;_Ux, _Dx&gt;(_Px, _Dt)); _CATCH_ALL // allocation failed, delete resource _Dt(_Px); _RERAISE; _CATCH_END &#125; //……限于篇幅，只列了一部分 &#125;; 然后是weak_ptr12345678910111213141516171819// TEMPLATE CLASS weak_ptrtemplate&lt;class _Ty&gt; class weak_ptr : public _Ptr_base&lt;_Ty&gt; &#123; // class for pointer to reference counted resourcepublic: weak_ptr() _NOEXCEPT &#123; // construct empty weak_ptr object &#125; weak_ptr(const weak_ptr&amp; _Other) _NOEXCEPT &#123; // construct weak_ptr object for resource pointed to by _Other this-&gt;_Resetw(_Other); &#125; ~weak_ptr() _NOEXCEPT &#123; // release resource this-&gt;_Decwref(); &#125; &#125;; 最后是unique_ptr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//先是一些帮助类template&lt;class _Val, class _Ty&gt; struct _Get_deleter_pointer_type _GET_TYPE_OR_DEFAULT(pointer, _Val *); // TEMPLATE CLASS _Unique_ptr_basetemplate&lt;class _Ty, class _Dx, bool _Empty_deleter&gt; class _Unique_ptr_base &#123; // stores pointer and deleterpublic: typedef typename remove_reference&lt;_Dx&gt;::type _Dx_noref; typedef typename _Get_deleter_pointer_type&lt;_Ty, _Dx_noref&gt;::type pointer; _Unique_ptr_base(pointer _Ptr, _Dx _Dt) : _Myptr(_Ptr), _Mydel(_Dt) &#123; // construct with pointer and deleter &#125; _Unique_ptr_base(pointer _Ptr) : _Myptr(_Ptr) &#123; // construct with pointer and deleter &#125; template&lt;class _Ptr2, class _Dx2&gt; _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 _Dt) : _Myptr(_Ptr), _Mydel(_Dt) &#123; // construct with compatible pointer and deleter &#125; template&lt;class _Ptr2&gt; _Unique_ptr_base(_Ptr2 _Ptr) : _Myptr(_Ptr) &#123; // construct with compatible pointer and deleter &#125; _Dx_noref&amp; get_deleter() &#123; // return reference to deleter return (_Mydel); &#125; const _Dx_noref&amp; get_deleter() const &#123; // return const reference to deleter return (_Mydel); &#125; pointer _Myptr; // the managed pointer _Dx _Mydel; // the deleter &#125;;template&lt;class _Ty, class _Dx&gt; class _Unique_ptr_base&lt;_Ty, _Dx, true&gt; : public _Dx &#123; // store pointer and empty deleterpublic: typedef _Dx _Mybase; typedef typename remove_reference&lt;_Dx&gt;::type _Dx_noref; //这里用到了traits技术，把类型抽出来了 typedef typename _Get_deleter_pointer_type&lt;_Ty, _Dx_noref&gt;::type pointer; _Unique_ptr_base(pointer _Ptr, _Dx _Dt) _NOEXCEPT : _Myptr(_Ptr), _Mybase(_Dt) &#123; // construct with pointer and deleter &#125; _Unique_ptr_base(pointer _Ptr) _NOEXCEPT : _Myptr(_Ptr) &#123; // construct with pointer and deleter &#125; //……限于篇幅，只列了一部分 pointer _Myptr; // the managed pointer&#125;;template&lt;class _Ty, class _Dx&gt; // = default_delete&lt;_Ty&gt; class unique_ptr : private _Unique_ptr_base&lt;_Ty, _Dx, is_empty&lt;_Dx&gt;::value || is_same&lt;default_delete&lt;_Ty&gt;, _Dx&gt;::value&gt; &#123; // non-copyable pointer to an objectpublic: typedef unique_ptr&lt;_Ty, _Dx&gt; _Myt; typedef _Unique_ptr_base&lt;_Ty, _Dx, is_empty&lt;_Dx&gt;::value || is_same&lt;default_delete&lt;_Ty&gt;, _Dx&gt;::value&gt; _Mybase; typedef typename _Mybase::pointer pointer; typedef _Ty element_type; typedef _Dx deleter_type; using _Mybase::get_deleter; unique_ptr() _NOEXCEPT : _Mybase(pointer()) &#123; // default construct static_assert(!is_pointer&lt;_Dx&gt;::value, \"unique_ptr constructed with null deleter pointer\"); &#125; unique_ptr(nullptr_t) _NOEXCEPT : _Mybase(pointer()) &#123; // null pointer construct static_assert(!is_pointer&lt;_Dx&gt;::value, \"unique_ptr constructed with null deleter pointer\"); &#125; //……限于篇幅，只列了一部分 //C++11关键字delete，或者用boost的noncopyable，或者自己手动不让拷贝也可以 unique_ptr(const _Myt&amp;) = delete; _Myt&amp; operator=(const _Myt&amp;) = delete;&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"关于weak_ptr的学习","slug":"关于weak_ptr的学习","date":"2016-09-01T15:04:56.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/09/01/关于weak_ptr的学习/","link":"","permalink":"http://yoursite.com/2016/09/01/关于weak_ptr的学习/","excerpt":"Linux-muduo-C++的1.10 shared_ptr 技术与陷阱中的现成的RAII handle 我认为RAII （资源获取即初始化）是C++ 语言区别于其他所有编程语言的最重要的特性，一个不懂RAII 的C++ 程序员不是一个合格的C++ 程序员。初学C++ 的教条是“new 和delete 要配对，new 了之后要记着delete”；如果使用RAII [CCS，条款13]，要改成“每一个明确的资源配置动作（例如new）都应该在单一语句中执行，并在该语句中立刻将配置获得的资源交给handle 对象（如shared_ptr），程序中一般不出现delete”。shared_ptr 是管理共享资源的利器，需要注意避免循环引用，通常的做法是owner 持有指向child 的shared_ptr，child 持有指向owner 的weak_ptr。","text":"Linux-muduo-C++的1.10 shared_ptr 技术与陷阱中的现成的RAII handle 我认为RAII （资源获取即初始化）是C++ 语言区别于其他所有编程语言的最重要的特性，一个不懂RAII 的C++ 程序员不是一个合格的C++ 程序员。初学C++ 的教条是“new 和delete 要配对，new 了之后要记着delete”；如果使用RAII [CCS，条款13]，要改成“每一个明确的资源配置动作（例如new）都应该在单一语句中执行，并在该语句中立刻将配置获得的资源交给handle 对象（如shared_ptr），程序中一般不出现delete”。shared_ptr 是管理共享资源的利器，需要注意避免循环引用，通常的做法是owner 持有指向child 的shared_ptr，child 持有指向owner 的weak_ptr。其中最后一句话 shared_ptr 是管理共享资源的利器，需要注意避免循环引用，通常的做法是owner 持有指向child 的shared_ptr，child 持有指向owner 的weak_ptr。 一般来讲，解除这种循环引用有下面有三种可行的方法： 1. 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。 2. 当parent的生存期超过children的生存期的时候，children改为使用一个普通指针指向parent。 3. 使用弱引用的智能指针打破这种循环引用。 虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。标准库中的弱引用的智能指针std::weak_ptr。(以前在boost库里，自从C++11后加入标准库)由于平时shared_ptr 用的稍多而weak_ptr用的很少，所以记录一下weak_ptr的笔记。123456789101112131415161718std::weak_ptrstd::weak_ptr&lt;T&gt;是标准库提供的一个弱引用的智能指针，它的声明可以简化如下：namespace std &#123; template&lt;typename T&gt; class weak_ptr &#123; public: template &lt;typename Y&gt; weak_ptr(const shared_ptr&lt;Y&gt;&amp; r); weak_ptr(const weak_ptr&amp; r); ~weak_ptr(); T* get() const; bool expired() const; shared_ptr&lt;T&gt; lock() const; &#125;;&#125; 可以看到，std::weak_ptr必须从一个std::share_ptr或另一个std::weak_ptr转换而来，这也说明，进行该对象的内存管理的是那个强引用的std::share_ptr。std::weak_ptr只是提供了对管理对象的一个访问手段。std::weak_ptr除了对所管理对象的基本访问功能（通过get()函数）外，还有两个常用的功能函数：expired()用于检测所管理的对象是否已经释放；lock()用于获取所管理的对象的强引用指针。 首先来个简单的例子—————weak_ptr.cpp—————12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;memory&gt;void observe(std::weak_ptr&lt;int&gt; weak)&#123; if (auto observe = weak.lock()) &#123; std::cout &lt;&lt; \"\\tobserve() able to lock weak_ptr&lt;&gt;, value=\" &lt;&lt; *observe &lt;&lt; \"\\n\"; &#125; else &#123; std::cout &lt;&lt; \"\\tobserve() unable to lock weak_ptr&lt;&gt;\\n\"; &#125;&#125;int main()&#123; std::weak_ptr&lt;int&gt; weak; std::cout &lt;&lt; \"weak_ptr&lt;&gt; not yet initialized\\n\"; observe(weak); &#123; auto shared = std::make_shared&lt;int&gt;(42); weak = shared; std::cout &lt;&lt; \"weak_ptr&lt;&gt; initialized with shared_ptr.\\n\"; observe(weak); &#125; std::cout &lt;&lt; \"shared_ptr&lt;&gt; has been destructed due to scope exit.\\n\"; observe(weak);&#125; 12345678g++ -Wall -Wextra -Werror -std=c++11 weak_ptr.cpp -o weak_ptr //或者gcc -lstdc++ -std=c++11 weak_ptr.cpp -o weak_ptr./weak_ptrweak_ptr&lt;&gt; not yet initialized observe() unable to lock weak_ptr&lt;&gt;weak_ptr&lt;&gt; initialized with shared_ptr. observe() able to lock weak_ptr&lt;&gt;, value=42shared_ptr&lt;&gt; has been destructed due to scope exit. observe() unable to lock weak_ptr&lt;&gt; 一个强引用当被引用的对象活着的话，这个引用也存在（就是说，当至少有一个强引用，那么这个对象就不能被释放）。std::share_ptr就是强引用。相对而言，弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。 看一个循环引用的例子12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;memory&gt;class parent;class children;typedef std::shared_ptr&lt;parent&gt; parent_ptr;typedef std::shared_ptr&lt;children&gt; children_ptr;class parent&#123;public: ~parent() &#123; std::cout &lt;&lt;\"destroying parent\\n\"; &#125;public: children_ptr children;&#125;;class children&#123;public: ~children() &#123; std::cout &lt;&lt;\"destroying children\\n\"; &#125;public: parent_ptr parent;&#125;;void test()&#123; parent_ptr father(new parent()); children_ptr son(new children); father-&gt;children = son; son-&gt;parent = father;&#125;void main()&#123; std::cout&lt;&lt;\"begin test...\\n\"; test(); std::cout&lt;&lt;\"end test.\\n\";&#125; 通过std::weak_ptr来打破循环引用由于弱引用不更改引用计数，类似普通指针，只要把循环引用的一方使用弱引用，即可解除循环引用。对于上面的那个例子来说，只要把children的定义改为如下方式，即可解除循环引用：123456789class children&#123;public: ~children() &#123; std::cout &lt;&lt;\"destroying children\\n\"; &#125;public: std::weak_ptr&lt;parent&gt; parent;&#125;;//child 持有指向owner 的weak_ptr。 虽然这种方法可以避免内存泄漏，但是还是需要倍加小心。正如那句话：构造容易，析构太难。特别是在多线程环境中，更需要考虑一些其他因素。路还很长。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"关于boost::noncopyable","slug":"关于boost::noncopyable","date":"2016-08-25T15:59:59.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/08/25/关于boost::noncopyable/","link":"","permalink":"http://yoursite.com/2016/08/25/关于boost::noncopyable/","excerpt":"最近开始看moduo库，其中的都继承了boost的noncopyable类，遂查看noncopyable源码","text":"最近开始看moduo库，其中的都继承了boost的noncopyable类，遂查看noncopyable源码12345678910111213141516171819202122232425262728#ifndef BOOST_NONCOPYABLE_HPP_INCLUDED #define BOOST_NONCOPYABLE_HPP_INCLUDED namespace boost &#123; // Private copy constructor and copy assignment ensure classes derived from // class noncopyable cannot be copied. // Contributed by Dave Abrahams namespace noncopyable_ // protection from unintended ADL &#123; class noncopyable &#123; protected: noncopyable() &#123;&#125; ~noncopyable() &#123;&#125; private: // emphasize the following members are private noncopyable( const noncopyable&amp; ); const noncopyable&amp; operator=( const noncopyable&amp; ); &#125;; &#125; typedef noncopyable_::noncopyable noncopyable; &#125; // namespace boost #endif // BOOST_NONCOPYABLE_HPP_INCLUDED 举例123456789101112131415161718class Test: public boost::noncopyable &#123; public: Test()&#123;&#125;; Test(int i)&#123;&#125;; ~Test()&#123;&#125;;&#125;; int main() &#123; Test cl1(); Test cl2(1); // Test cl3(cl1); // error // Test cl4=cl2; // error return 0; &#125; 其实如果编译器支持C++11（这个年头大多数编译器都支持了，但是还是要看实际项目），也可以使用C++11中的delete关键字不让编译器为我们自动生成这两个函数。如下：1234567891011121314151617181920class Test:public: Test()&#123;&#125;; Test(int i)&#123;&#125;; ~Test()&#123;&#125;;private: Test( const Test&amp; ) = delete; const Test&amp; operator=( const Test&amp; ) = delete;&#125;; int main() &#123; Test cl1(); Test cl2(1); // Test cl3(cl1); // error // Test cl4=cl2; // error return 0; &#125; 相当于把拷贝构造函数和拷贝操作符设置为私有，这样做的好处就是除非子类自定义这两个函数，否则是不能进行拷贝操作产生子类的对象。例如单例模式，或者多线程同步（自定义互斥锁的类）等等","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"boost","slug":"boost","permalink":"http://yoursite.com/tags/boost/"}]},{"title":"关于TCP产生的粘包以及解决方案","slug":"关于TCP产生的粘包以及解决方案","date":"2016-08-10T15:40:28.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/08/10/关于TCP产生的粘包以及解决方案/","link":"","permalink":"http://yoursite.com/2016/08/10/关于TCP产生的粘包以及解决方案/","excerpt":"最近在看UNP，无意间翻到别人的一篇博客，关于TCP粘包问题的。自己这方面不是很了解，故作此记录。 在网络编程中，发送端可以1K,1K的发数据，但是接收端可以2k,2k的去数据，或者3K，或者4K等等，在应用层是不知道传输层怎么传的，这也是抽象的意义所在。因为TCP是“字节流”协议，没有消息边界所引起的，所以会产生粘包。举个例子：","text":"最近在看UNP，无意间翻到别人的一篇博客，关于TCP粘包问题的。自己这方面不是很了解，故作此记录。 在网络编程中，发送端可以1K,1K的发数据，但是接收端可以2k,2k的去数据，或者3K，或者4K等等，在应用层是不知道传输层怎么传的，这也是抽象的意义所在。因为TCP是“字节流”协议，没有消息边界所引起的，所以会产生粘包。举个例子：主机A向主机B发送2个包，都是20K，由于不知道B如何提取数据，可能提取的解决方案如下：1、B提取2次，每次20K2、B提取2次，第一次10K，第二次30K3、B提取4次，第一次5K,第二次10K，第三次15K，第四次10K4、任意次数组合，只要总和也是40K就行 粘包问题的解决方案：1、包尾加分隔符，如\\r\\n（ftp）2、定包长3、包头加上包体长度4、自定义应用层协议 1、方案存在的问题，加入要传输的包本生就含有分隔符，那么就会出现问题 2、定包长，如unix network proggramming附录所携带的样例源代码unpv13e/lib/writen.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ssize_t /* Write \"n\" bytes to a descriptor. */writen(int fd, const void *vptr, size_t n)&#123; size_t nleft; ssize_t nwritten; const char *ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) &#123; if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123; if (nwritten &lt; 0 &amp;&amp; errno == EINTR) nwritten = 0; /* and call write() again */ else return(-1); /* error */ &#125; nleft -= nwritten; ptr += nwritten; &#125; return(n);&#125;/* end writen */voidWriten(int fd, void *ptr, size_t nbytes)&#123; if (writen(fd, ptr, nbytes) != nbytes) err_sys(\"writen error\");&#125;ssize_t /* Read \"n\" bytes from a descriptor. */readn(int fd, void *vptr, size_t n)&#123; size_t nleft; ssize_t nread; char *ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) &#123; if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123; if (errno == EINTR) nread = 0; /* and call read() again */ else return(-1); &#125; else if (nread == 0) break; /* EOF */ nleft -= nread; ptr += nread; &#125; return(n - nleft); /* return &gt;= 0 */&#125;/* end readn */ssize_tReadn(int fd, void *ptr, size_t nbytes)&#123; ssize_t n; if ( (n = readn(fd, ptr, nbytes)) &lt; 0) err_sys(\"readn error\"); return(n);&#125; 但是这种方案也是有它的缺点的，如果我们在项目中使用了这种方案,那我们每次读写的大小应该是一致的，比如1024Byte,这就是缺点所在，不能根据实际情况来读写，容易造成网络堵塞，比如我只想发一个字节，也必须发送1024Byte，造成网络的浪费。 3、包头加上包体长度 12345678910111213141516171819202122232425262728293031323334struct packet &#123; int len; char buf[1024];&#125;;void echo_server(int conn)&#123; struct packet recvbuf; int n; while (1) &#123; memset(&amp;recvbuf, 0, sizeof(recvbuf)); int ret = readn(conn, &amp;recvbuf.len, 4); if (ret == -1) ERR_EXIT(\"read error\"); else if (ret &lt; 4) //客户端关闭 &#123; printf(\"client close\\n\"); break; &#125; n = ntohl(recvbuf.len); ret = readn(conn, recvbuf.buf, n); if (ret == -1) ERR_EXIT(\"read error\"); if (ret &lt; n) //客户端关闭 &#123; printf(\"client close\\n\"); break; &#125; fputs(recvbuf.buf, stdout); writen(conn, &amp;recvbuf, 4 + n); &#125;&#125; 4、自定义应用层协议其实第三条也算是第四条的子集，只不过自定义应用层协议各种各样，可以按照自己的项目自己定制，自由度比较大，比如TLV 编解码格式（type,length,value）12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;#include&lt;stdint.h&gt; //一些类型的typedef#include&lt;cstring&gt;using namespace std;struct TLV&#123; //type length value uint8_t tag; uint16_t len; char value[0]; //c99柔性数组&#125;__attribute__((packed));int main()&#123; const char *szMSG=\"hello world\"; cout&lt;&lt;szMSG&lt;&lt;endl; uint16_t len=strlen(szMSG)+1; struct TLV *pTLV; pTLV=(struct TLV*)malloc(sizeof(struct TLV)+sizeof(char)*len); pTLV-&gt;tag=0x2; pTLV-&gt;len=len; memcpy(pTLV-&gt;value,szMSG,len); cout&lt;&lt;pTLV-&gt;value&lt;&lt;endl; free(pTLV); pTLV=NULL; return 0;&#125;//hello world//hello world 为结构体分配内存时，malloc一段结构体大小加上可变长数据长度的空间给它，可变长部分可按数组的方式访问，释放时，直接把整个结构体free掉就可以了。attribute(packed)用来强制不对struct TLV进行4字节对齐，目的是为了获取真实的TLV的空间使用情况。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"mysql学习笔记(2)","slug":"mysql学习笔记_2","date":"2016-08-07T13:44:56.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/08/07/mysql学习笔记_2/","link":"","permalink":"http://yoursite.com/2016/08/07/mysql学习笔记_2/","excerpt":"5月份实习面试被问到对mysql的MyISAM和InnoDB两种存储引擎的看法，当时并没有接触到，所以没有答上来。这段时间在实习之余抽出时间来看了一下这块知识点，给自己做一个记录。","text":"5月份实习面试被问到对mysql的MyISAM和InnoDB两种存储引擎的看法，当时并没有接触到，所以没有答上来。这段时间在实习之余抽出时间来看了一下这块知识点，给自己做一个记录。//mysql使用某个引擎CREATE TABLE t (i INT) ENGINE = MYISAM; //或者InnoDB、MERGE、BDB等等，但是主流还是MYISAM与InnoDB MySQL默认的存储引擎是MyISAM，其他常用的就是InnoDB。 MyISAM与InnoDB的对比 MyISAM 存储结构：每张表被存放在三个文件： 1、frm-表格定义 2、MYD(MYData)-数据文件 3、MYI(MYIndex)-索引文件存储空间： MyISAM可被压缩，存储空间较小可移植性、备份及恢复：由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作事务安全：不支持 每次查询具有原子性AUTO_INCREMENT：MyISAM表可以和其他字段一起建立联合索引SELECT：优于InnoDBINSERT：差于InnoDBUPDATE：差于InnoDBDELETE：差于InnoDBCOUNT without WHERE：优于InnoDB,因为MyISAM保存了表的具体行数。COUNT with WHERE：与InnoDB一样锁：只支持表锁外键：不支持FULL TEXT全文索引：支持 InnoDB 存储结构：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB存储空间：InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引可移植性、备份及恢复：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了事务安全：支持 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表AUTO_INCREMENT：InnoDB中必须包含只有该字段的索引SELECT：差于MyISAMINSERT：优于MyISAMUPDATE：优于MyISAMDELETE：优于MyISAMCOUNT without WHERE：差于InnoDB,InnoDB没有保存表的具体行数，需要逐行扫描统计COUNT with WHERE：与MyISAM一样锁：支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的外键：支持FULL TEXT全文索引：以前不支持 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点（5.6.4开始支持） 总的来说，MyISAM和InnoDB各有优劣，各有各的使用环境。但是InnoDB的设计目标是处理大容量数据库系统，它的CPU利用率是其它基于磁盘的关系数据库引擎所不能比的。 结论如下使用MyISAM的情况：如果需要非常频繁的读，但是几乎不进行写操作需要全文索引（Full-text search）并且mysql版本小于等于5.5否则使用InnoDB是个更好的选择","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"mysql学习笔记(1)","slug":"mysql学习笔记_1","date":"2016-08-07T13:11:11.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/08/07/mysql学习笔记_1/","link":"","permalink":"http://yoursite.com/2016/08/07/mysql学习笔记_1/","excerpt":"1、问：如果有一张表，里面有个字段为id的自增主键，当已经向表里面插入了10条数据之后，删除了id为8，9，10的数据，再把mysql重启，之后再插入一条数据，那么这条数据的id值应该是多少，是8，还是11？","text":"1、问：如果有一张表，里面有个字段为id的自增主键，当已经向表里面插入了10条数据之后，删除了id为8，9，10的数据，再把mysql重启，之后再插入一条数据，那么这条数据的id值应该是多少，是8，还是11？答：如果表的类型为MyISAM，那么是11。如果表的类型为InnoDB，则id为8。这是因为两种类型的存储引擎所存储的最大ID记录的方式不同，MyISAM表将最大的ID记录到了数据文件里，重启mysql自增主键的最大ID值也不会丢失；而InnoDB则是把最大的ID值记录到了内存中，所以重启mysql或者对表进行了OPTIMIZE操作后，最大ID值将会丢失。验证在本文最后一条2、查看表定义1desc testTable; 3、修改表名，将表testTable改为test1alter table testTable rename test; 4、修改字段的数据类型：将id字段的int类型改为bigint1alter table test modify id bigint; 5、修改字段名：MYSQL里修改字段名的时候需要加上字段的数据类型否则会报错1alter table test change id ID bigint; 6、添加字段1alter table test add name nvarchar(100) null; 7、删除字段1alter table test drop name; 8、删除表1drop table test1; 删除多个表,删除之前要先判断一下9、模版建表1create table test1 like test; 1create table test2 as select * from test; 10、查看表状态1show table status like &apos;test_innodb&apos;\\G 注意这里没加分号 11、验证第一条innodb引擎测试创建表为innodb引擎并且自增，查看表的状态插入3条数据删除id为2和id为3的数据，然后重启mysql服务器，再插入一条数据，发现新插入的id为2 myisam引擎测试创建表为myisam引擎并且自增，查看表的状态插入3条数据删除id为2和id为3的数据，然后重启mysql服务器，再插入一条数据，发现新插入的id为4","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Lua学习笔记","slug":"Lua学习笔记","date":"2016-06-04T15:16:04.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/06/04/Lua学习笔记/","link":"","permalink":"http://yoursite.com/2016/06/04/Lua学习笔记/","excerpt":"Lua语法细节","text":"Lua语法细节 1) a.x和a[x]的区别，前者表示以字符串”x”的形式来索引table。后者是以变量x的值来索引table。举例如下： 123456a=&#123;&#125;x=&quot;y&quot;a[x]=10print(a[x]) -- 10print(a.x) -- nilprint(a.y) -- 10 2) 可以在字符串前放置”#“来获得该字符串的长度123a=&quot;Hello world&quot;print(#a) -- 11print(#&quot;good\\n&quot;) -- 5 3) 通常以1作为下标的起始值,长度操作符”#“用于返回一个数组或线性表的最后一个索引值(或为其大小)。举例如下：12345678a=&#123;&#125;a[1]=&quot;123&quot;a[2]=456a[3]=&quot;hello&quot;for i=1, #a do print(a[i])end 123print(a&#123;#a&#125;) --打印a的最后一个值a[#a]=nil --删除a的最后一个值a[#a+1]=&quot;1&quot; --在a末尾添加一个为”1“的值 4) 对所有未初始化的元素的索引结果都是nil。Lua将nil作为数组结尾的标志。当一个数组有”空隙(Hole)“时,即中间含有nil时，长度操作符会认为这些nil元素就是结尾的标记。12345a=&#123;&#125;a[1000]=1print(#a) -- 0print(table.maxn(a)) -- 1000 （Lua5.1 新函数） 5)Lua允许多重赋值,例如：12345678a,b=10,2*x --a为10，b为2*xx,y=y,x --交换x,ya,b,c=0,1 print(a,b,c) --0 1 nila,b=a+1,b+1,b+2 --b+2会被忽略print(a,b) --1,2a,b,c=0print(a,b,c) --0 nil nil 6)局部变量与全局变量12345678910111213141516171819202122x=10local i=1 --局部变量while i&lt;=x do local x=i*2 --局部变量 print(x) --2 4 6 8…… i=i+1endif i&gt;20 then local x x=20 print(x+2) --22else print(x) --10 全局变量endprint(x) --10 全局变量local foo=foo --这句代码创建了一个局部变量foo，并将用全局变量foo的值初始化它。如果后续其他函数改变了全局foo的值，那么可以在这里先 --将它的值保存起来。用这种方式还可以加速在当前作用域中对foo的访问。 7)控制结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748--if语句先测试其条件，然后根据测试结果执行then部分或else部分。else部分是可选的。if a&lt;0 then a=0 endif a&lt;b then return a else return b endif line&gt;maxlines then showpage() line=0endif op==&quot;+&quot; then --由于Lua不支持switch语句，所以这种多重if-else代码很常见 r=a+belseif op==&quot;-&quot; r=a-belseif op==&quot;*&quot; r=a*belseif op==&quot;/&quot; r=a/belse error(&quot;invalid operation&quot;)end--repeatrepeat line=io.read()until line~=&quot;&quot;print(line)local sqr=x/2 --与其他大多数语言不同的是，在Lua中,一个声明在循环体中的局部变量的作用域包括了条件测试(Lua5.1的新功能)repeat sqr=(sqr+x/sqr)/2 local error=math.abs(sqr^2-x)until error&lt;x/10000 --在此可以访问error--数字型forfor var=exp1,exp2,exp3 do --var从exp1变化到exp2，每次变化都以ex3作为步长递增var，并执行一次执行体。若不指定ex3，则为1 &lt;执行体&gt;end--例如for i=1,f(x) do print(i) end --f(x)只会执行一次for i=10,1,-1 do print(i) end--泛型forfor i,v in ipairs(a) do print(v) end --打印数组a的所有值(Lua的基础库提供了ipairs,这是一个用于遍历数组的迭代器函数)for k in pairs(t) do print(k) end --打印table t中所有的key 8)函数1234567891011121314151617181920212223242526272829303132--多重返回值function foo0() endfunction foo1() return &quot;a&quot;,&quot;b&quot; endx,y=foo1(),20 --x=&quot;a&quot;,y=20(如果一个函数调用不是一系列表达式的最后一个元素，那么将只产生一个值)x,y=foo0(),20,30 --x=nil,y=20print(foo1(),1) --a 1print(foo1()..&quot;x&quot;) --ax(当foo1出现在一个表达式中，Lua会将其返回值数量调整为1)print((foo0())) --nil(将函数调用放入一对圆括号中，迫使它只返回一个结果)print((foo1())) --a--变长参数function add(...)local s=0 for i,v in ipairs&#123;...&#125; do s=s+v endreturn sendfor i=1,select(&apos;#&apos;,...) do --使用select来遍历一个函数的所有变长参数(select(&quot;#&quot;,...)会返回所有变长参数的总数，其中包括nil)local arg=select(i,...) --得到第i个参数 &lt;循环体&gt;end--具名实参rename(old=&quot;tmp.lua&quot;,new=&quot;tmp1.lua&quot;) --无效的代码rename&#123;old=&quot;tmp.lua&quot;,new=&quot;tmp1.lua&quot;&#125; --将实参组织到一个table中，并将这个table作为作为唯一的实参传给函数。当实参只有一个table时，()可以省略function rename(arg) --这样也是可以的 return os.rename(arg.old,arg.new)end","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"The_Linux_Programming_Interface读书笔记","slug":"The_Linux_Programming_Interface读书笔记","date":"2016-05-20T12:49:40.000Z","updated":"2017-12-07T13:56:55.000Z","comments":true,"path":"2016/05/20/The_Linux_Programming_Interface读书笔记/","link":"","permalink":"http://yoursite.com/2016/05/20/The_Linux_Programming_Interface读书笔记/","excerpt":"If a child process becomes orphaned because its “birth” parent terminates,then the child is adopted by the init process, and subsequent calls to getppid() in the child return 1 (see Section 26.2).","text":"If a child process becomes orphaned because its “birth” parent terminates,then the child is adopted by the init process, and subsequent calls to getppid() in the child return 1 (see Section 26.2). The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments,and return value. Stack frames are discussed in more detail in Section 6.5.The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Locations of program variables in process memory segments––––––––––––––––––––––––––––––––––––––––––––––––––––––– proc/mem_segments.c12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char globBuf[65536]; /* Uninitialized data segment */int primes[] = &#123; 2, 3, 5, 7 &#125;; /* Initialized data segment */static intsquare(int x) /* Allocated in frame for square() */&#123; int result; /* Allocated in frame for square() */ result = x * x; return result; /* Return value passed via register */&#125;static voiddoCalc(int val) /* Allocated in frame for doCalc() */&#123; printf(\"The square of %d is %d\\n\", val, square(val)); if (val &lt; 1000) &#123; int t; /* Allocated in frame for doCalc() */ t = val * val * val; printf(\"The cube of %d is %d\\n\", val, t); &#125;&#125;intmain(int argc, char *argv[]) /* Allocated in frame for main() */&#123; static int key = 9973; /* Initialized data segment */ static char mbuf[10240000]; /* Uninitialized data segment */ char *p; /* Allocated in frame for main() */ p = malloc(1024); /* Points to memory in heap segment */ doCalc(key); exit(EXIT_SUCCESS);&#125; ––––––––––––––––––––––––––––––––––––––––––––––––––––––– proc/mem_segments.c putenv() returns a nonzero value on error, rather than –1. In some circumstances, the use of setenv() and clearenv() can lead to memory leaks in a program. We noted above that setenv() allocates a memory buffer that is then made part of the environment. When we call clearenv(), it doesn’t free this buffer (it can’t, since it doesn’t know of the buffer’s existence). A program that repeatedly employed these two functions would steadily leak memory.","categories":[{"name":"阅读","slug":"阅读","permalink":"http://yoursite.com/categories/阅读/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}]},{"title":"HelloWorld","slug":"HelloWorld","date":"2016-05-20T12:00:00.000Z","updated":"2017-12-08T14:32:52.000Z","comments":true,"path":"2016/05/20/HelloWorld/","link":"","permalink":"http://yoursite.com/2016/05/20/HelloWorld/","excerpt":"","text":"欢迎来到我的世界 ~","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]}]}